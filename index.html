<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turnierplaner</title>
    <style>
        /* Allgemeine Stile für den Body */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }

        /* Überschrift des Planers */
        h1 {
            color: #0056b3;
            text-align: center;
            margin-bottom: 30px;
        }

        /* Hauptcontainer für den Inhalt */
        .container {
            max-width: 1600px; /* Increased max-width for side-by-side layout of schedule and final table */
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex; /* Use flexbox for the main content layout */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 20px; /* Space between schedule and tables */
        }

        /* Konfigurations-, Team-Benennungs- und Turnierdetails-Sektionen */
        .config-section, .team-naming-section, .tournament-details-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background-color: #f9f9f9;
            width: 100%; /* Take full width on their respective screens */
        }

        /* Überschriften der Sektionen */
        .config-section h2, .team-naming-section h2, .tournament-details-section h2, .cross-games-section h2, .final-round-section h2, .preliminary-round-section h2, .placement-round-section h2, .overall-standings-section h2, .final-rankings-section h2 { /* Updated selectors */
            color: #0056b3;
            margin-bottom: 15px;
            border-bottom: 1px solid #cce5ff;
            padding-bottom: 5px;
        }

        /* Formulargruppen für Labels und Inputs */
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input[type="number"],
        .form-group input[type="text"],
        .form-group input[type="time"],
        .form-group select {
            width: calc(100% - 22px); /* Passt sich an Padding und Border an */
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        /* Styling für den Logo-Upload-Bereich */
        .logo-upload-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
            margin-bottom: 15px;
        }
        .logo-upload-group input[type="file"] {
            width: auto;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .team-logo-preview {
            width: 30px; /* Kleinere Vorschau */
            height: 30px;
            border: 1px solid #ddd;
            border-radius: 4px;
            object-fit: contain; /* Bild im Rahmen halten */
            background-color: #f0f0f0;
            padding: 2px;
            display: none; /* Standardmäßig ausgeblendet */
        }
        .team-logo-preview.active {
            display: inline-block; /* Anzeigen, wenn ein Logo hochgeladen ist */
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            margin-top: 10px;
            margin-right: 10px; /* Added for spacing between buttons */
        }
        .btn:hover:not(:disabled) {
            background-color: #0056b3;
        }
        .btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .btn.btn-back {
            background-color: #6c757d;
        }
        .btn.btn-back:hover:not(:disabled) {
            background-color: #5a6268;
        }

        /* Turnierbildschirm Container */
        #tournament-screen {
            display: flex;
            width: 100%;
            gap: 20px;
            flex-wrap: wrap; /* Allow wrapping columns on smaller screens */
            flex-direction: row; /* Columns side-by-side */
            align-items: flex-start; /* Align columns to the top */
        }

        /* Linker Bereich für den Spielplan */
        #game-schedule-column {
            flex: 2; /* Takes 2 parts of available space, larger than side tables */
            min-width: 500px; /* Minimum width to prevent schedule from being too narrow */
            padding: 20px;
            background-color: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
        }

        /* Wrapper für die Tabellen rechts neben dem Spielplan */
        #side-tables-wrapper {
            flex: 1; /* Takes 1 part of available space */
            min-width: 350px; /* Minimum width for tables */
            display: flex;
            flex-direction: column; /* Stack tables vertically within this wrapper */
            gap: 20px; /* Space between group tables and overall standings */
            padding: 0; /* Wrapper itself doesn't need padding */
        }

        /* Gruppentabellen und Gesamtrangliste innerhalb des side-tables-wrapper */
        #group-tables-container, .overall-standings-card {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 20px;
            background-color: #f9f9f9;
        }
        
        /* Container für die Endrundentabelle (ganz unten) */
        #final-rankings-wrapper { /* New wrapper for final rankings */
            width: 100%; /* Takes full width at the bottom */
            margin-top: 20px; /* Space from content above */
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Gruppendivs in der Tabellenspalte und Finaltabelle */
        .group-table-card, .final-round-card, .placement-round-card, .overall-standings-card, .final-rankings-card { /* Updated selectors */
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 20px;
            background-color: #f9f9f9;
        }
        .group-table-card h2, .final-round-card h2, .placement-round-card h2, .overall-standings-card h2, .final-rankings-card h2 { /* Updated selectors */
            color: #0056b3;
            margin-bottom: 20px;
            border-bottom: 2px solid #0056b3;
            padding-bottom: 10px;
            margin-top: 0;
            font-size: 1.2em;
        }

        /* Tabellenstile für Gruppentabellen und Abschlusstabelle */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px; /* Slightly reduced padding for tables */
            text-align: left;
            font-size: 0.9em; /* Smaller font for table data */
        }
        th {
            background-color: #eaf2f8;
            color: #333;
            font-weight: bold;
        }
        td {
            background-color: #fff;
        }
        tr:nth-child(even) td {
            background-color: #f6f6f6;
        }

        /* Eingabefelder für Spielergebnisse */
        .match-input {
            display: flex;
            align-items: center;
            gap: 8px; /* Reduced gap */
            margin-bottom: 8px; /* Reduced margin */
            padding: 6px; /* Reduced padding */
            border: 1px solid #eee;
            border-radius: 4px;
            background-color: #fff;
            flex-wrap: wrap; /* Allow wrapping of match elements if screen is narrow */
        }
        .match-input input[type="number"] {
            width: 50px; /* Slightly smaller input width */
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .match-input button {
            padding: 6px 12px; /* Reduced button padding */
            background-color: #007bff; /* Changed to primary blue */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em; /* Smaller button font */
            transition: background-color 0.3s ease;
        }
        .match-input button:hover:not(:disabled) {
            background-color: #0056b3; /* Darker blue on hover */
        }
        /* Style for the button after score is recorded */
        .match-input button.recorded {
            background-color: #28a745; /* Success green */
            color: white;
            cursor: default; /* Keep default cursor for "Gespeichert!" */
        }
        .match-input button.recorded:hover {
            background-color: #218838; /* Slightly darker green on hover for "Gespeichert!" */
        }
        .match-input button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }


        .team-name {
            font-weight: bold;
            color: #555;
            white-space: nowrap; /* Prevent team names from wrapping */
        }

        /* Team Logo im Spielplan und in der Tabelle */
        .team-logo {
            height: 18px; /* Smaller size for logos */
            width: 18px;
            margin-right: 4px;
            vertical-align: middle;
            border: 1px solid #eee;
            border-radius: 3px;
            object-fit: contain;
        }

        /* Match time and table display */
        .match-time-table {
            font-weight: bold;
            margin-right: 8px;
            color: #007bff;
            white-space: nowrap; /* Prevent time/table from wrapping */
        }


        /* Checkbox-Option für Cross-Spiele */
        .cross-game-option {
            margin-top: 20px;
            margin-bottom: 30px;
            padding: 15px;
            background-color: #eaf2f8;
            border: 1px solid #cce5ff;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .cross-game-option input[type="checkbox"] {
            transform: scale(1.2); /* Checkbox etwas kleiner machen als vorher, aber immer noch sichtbar */
        }
        .cross-game-option label {
            font-size: 1em; /* Reduced font size */
            color: #004085;
        }

        /* Visuelle Hervorhebung für Cross-Spiele */
        .cross-game-match {
            background-color: #ffeeba; /* Hellgelb */
            border-color: #ffc107;
        }

        /* Visuelle Hervorhebung für Finalrunden-Spiele */
        .final-round-match {
            background-color: #d4edda; /* Hellgrün */
            border-color: #28a745;
        }

        /* Visuelle Hervorhebung für Platzierungsrunden-Spiele */
        .placement-round-match {
            background-color: #f8e2e2; /* Hellrot */
            border-color: #dc3545;
        }

        /* Visuelle Hervorhebung für die neuen 'kleinen Halbfinals' */
        .small-semi-final-match {
            background-color: #fff3cd; /* Light orange/yellow, similar to cross-games but distinct */
            border-color: #ffc107;
        }


        /* Zusammenfassung der Turnierdetails */
        #tournament-details-summary {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #eaf8e2; /* Hellgrün */
            border: 1px solid #d4edda;
            border-radius: 5px;
            font-size: 0.9em; /* Smaller font size */
            color: #155724;
            width: 100%; /* Take full width at the top of the tournament screen */
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) { /* Adjusted breakpoint for three columns */
            #tournament-screen {
                flex-direction: column; /* Stack columns vertically on smaller screens */
            }
            #game-schedule-column, #side-tables-wrapper, #final-rankings-wrapper { /* Adjusted selector */
                flex: none; /* Remove flex sizing */
                width: 100%; /* Take full width */
                min-width: unset; /* Remove min-width constraint */
                margin-left: 0; /* Remove left margin when stacked */
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Turnierplaner</h1>

        <div id="start-screen" style="display: block;">
            <div class="config-section">
                <h2>Turnier konfigurieren</h2>
                <div class="form-group">
                    <label for="numGroups">Anzahl der Gruppen (max. 3):</label>
                    <input type="number" id="numGroups" min="1" max="3" value="3">
                </div>
                <div class="form-group">
                    <label for="teamsPerGroup">Teams pro Gruppe (max. 5):</label>
                    <input type="number" id="teamsPerGroup" min="2" max="5" value="5">
                </div>
                <button class="btn" onclick="goToDetailConfiguration()">Weiter zur Detail-Konfiguration</button>
            </div>
        </div>

        <div id="tournament-details-screen" style="display:none;">
            <div class="tournament-details-section">
                <h2>Turnier-Details festlegen</h2>
                <div class="form-group">
                    <label for="startTime">Turnier-Startzeit:</label>
                    <input type="time" id="startTime" value="09:00">
                </div>
                <div class="form-group">
                    <label for="matchDuration">Spiellänge pro Spiel (Minuten):</label>
                    <input type="number" id="matchDuration" min="1" value="10">
                </div>
                <div class="form-group">
                    <label for="breakDuration">Pausenzeit zwischen Spielen (Minuten):</label>
                    <input type="number" id="breakDuration" min="0" value="5">
                </div>
                <div class="form-group">
                    <label for="numTables">Anzahl der Spieltische:</label>
                    <input type="number" id="numTables" min="1" value="1">
                </div>
                <button class="btn btn-back" onclick="showScreen('start-screen')">Zurück</button>
                <button class="btn" onclick="configureTeams()">Weiter zur Team-Benennung</button>
            </div>
        </div>

        <div id="team-naming-screen" style="display:none;">
            <div class="team-naming-section">
                <h2>Team-Namen eingeben und Logos hochladen</h2>
                <div id="teamNameInputs">
                </div>
                <button class="btn btn-back" onclick="showScreen('tournament-details-screen')">Zurück</button>
                <button class="btn" onclick="generateTournament()">Turnier generieren</button>
            </div>
        </div>

        <div id="tournament-screen" style="display:none;">
            <div id="tournament-details-summary">
            </div>

            <div style="width: 100%; display: flex; flex-wrap: wrap; gap: 20px;">
                <div class="cross-game-option" style="flex: 1; display: none;">
                    <input type="checkbox" id="enableCrossGames" checked style="display: none;"> <label for="enableCrossGames" style="display: none;">Cross-Gruppen-Spiele aktivieren</label>
                </div>
            </div>

            <div id="game-schedule-column">
                <div id="preliminary-round-section"> <h2>Spielplan Vorrunde</h2>
                    <div id="scheduled-matches-container">
                    </div>
                </div>

                <div id="placement-round-section" class="placement-round-section" style="display:none;">
                    <h2>Platzierungsrunde</h2>
                    <div id="placement-matches-container">
                    </div>
                </div>

                <div id="final-round-section" class="final-round-section" style="display:none;">
                    <h2>Viertelfinale</h2>
                    <div id="quarter-finals-container">
                    </div>
                    <h2>Kleines Halbfinale (Platz 5-8)</h2>
                    <div id="small-semi-finals-container">
                    </div>
                    <h2>Spiel um Platz 7</h2>
                    <div id="seventh-place-container">
                    </div>
                    <h2>Spiel um Platz 5</h2>
                    <div id="fifth-place-container">
                    </div>
                    <h2>Halbfinale</h2>
                    <div id="semi-finals-container">
                    </div>
                    <h2>Spiel um Platz 3</h2>
                    <div id="third-place-container">
                    </div>
                    <h2>Finale</h2>
                    <div id="final-container">
                    </div>
                </div>

                <div id="cross-games-section" class="cross-games-section" style="display:none;"> <h2>Cross-Gruppen-Spiele</h2>
                    <div id="cross-games-container">
                    </div>
                </div>
            </div>

            <div id="side-tables-wrapper">
                <div id="group-tables-container">
                    <h2>Tabellen Vorrunde</h2> 
                    </div>

                <div class="overall-standings-card" style="display: block;">
                    <h2>Gesamtrangliste (nach Vorrunde)</h2>
                    <table id="overall-standings-table">
                        <thead>
                            <tr>
                                <th>Platz</th>
                                <th>Team</th>
                                <th>Punkte</th>
                                <th>Tordiff.</th>
                                <th>Tore</th>
                            </tr>
                        </thead>
                        <tbody id="overall-standings-table-body">
                        </tbody>
                    </table>
                </div>
            </div>

            <div id="final-rankings-wrapper" style="display: block;">
                <div class="final-rankings-card" style="display: none;"> <h2>Endrundentabelle</h2>
                    <table id="final-rankings-table">
                        <thead>
                            <tr>
                                <th>Platz</th>
                                <th>Team</th>
                            </tr>
                        </thead>
                        <tbody id="final-rankings-table-body">
                        </tbody>
                    </table>
                </div>
            </div>

            <button class="btn btn-back" style="width: 100%; margin-top: 20px;" onclick="showScreen('team-naming-screen')">Zurück zur Team-Benennung</button>
        </div>
    </div>

    <script>
        // Globale Variablen für Turnierkonfiguration
        let numGroups = 3; // Angepasst auf 3 Gruppen
        let teamsPerGroup = 5; // Angepasst auf 5 Teams
        let startTime = '09:00';
        let matchDuration = 10;
        let breakDuration = 5;
        let numTables = 1;

        // Objekt zum Speichern der Teamnamen, gruppiert nach Gruppen
        let groups = {};

        // Datenstrukturen für Spielstatistiken und Ergebnisse
        const teamStats = {};       // Speichert die Statistiken für jedes Team
        const teamLogos = {};       // Speichert die Data URLs der Team-Logos
        const groupMatchResults = {};    // Speichert die Ergebnisse der regulären Gruppenspiele
        const finalRoundMatchResults = {'global': []}; // Speichert die Ergebnisse der Finalrunden- und Platzierungsspiele
        let preliminaryRoundSchedule = []; // Speichert nur den Spielplan der Vorrunde
        let placementRoundSchedule = []; // Speichert den Spielplan der Platzierungsrunde
        let quarterFinalsSchedule = []; // Speichert den Spielplan des Viertelfinals
        let smallSemiFinalsSchedule = []; // NEU: Speichert den Spielplan des kleinen Halbfinals
        let seventhPlaceMatchSchedule = []; // NEU: Speichert den Spielplan des Spiels um Platz 7
        let fifthPlaceMatchSchedule = []; // NEU: Speichert den Spielplan des Spiels um Platz 5
        let semiFinalsSchedule = []; // Speichert den Spielplan des Halbfinals
        let thirdPlaceMatchSchedule = []; // Speichert den Spielplan des Spiels um Platz 3
        let finalMatchSchedule = []; // Speichert den Spielplan des Finales

        // Variable, um die Endzeit der Gruppenphasen zu speichern
        let groupStageEndTime = null;
        let placementRoundStartTime = null; // Startzeit für Platzierungsspiele
        let quarterFinalsStartTime = null; // Startzeit für Viertelfinals
        let smallSemiFinalsStartTime = null; // NEU: Startzeit für kleines Halbfinale


        // NEU: Endgültige Platzierungen (wird befüllt, wenn Plätze feststehen)
        const finalRankings = {}; // { 1: 'Team A', 2: 'Team B', ... }

        // Funktion zum Wechseln der sichtbaren Bildschirme
        function showScreen(screenId) {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('tournament-details-screen').style.display = 'none';
            document.getElementById('team-naming-screen').style.display = 'none';
            document.getElementById('tournament-screen').style.display = 'none';

            if (screenId === 'tournament-screen') {
                document.getElementById(screenId).style.display = 'flex';
            } else {
                document.getElementById(screenId).style.display = 'block';
            }
        }

        // Initialisiert oder setzt alle Turnierdaten zurück (Statistiken, Spielergebnisse)
        function initializeTournamentData() {
            // Lösche alle vorhandenen Team-Statistiken
            for (const teamName in teamStats) {
                delete teamStats[teamName];
            }
            // Lösche alle vorhandenen Gruppen-Match-Ergebnisse
            for (const groupKey in groupMatchResults) {
                delete groupMatchResults[groupKey];
            }
            // Reset Finalrunden-Ergebnisse (jetzt Platzierungsrunden und K.O.-Runden)
            finalRoundMatchResults['global'] = []; // Ensure it's always an array
            preliminaryRoundSchedule = []; // Reset Vorrunden-Spielplan
            placementRoundSchedule = []; // Reset Platzierungsrunden-Spielplan
            quarterFinalsSchedule = []; // Reset Viertelfinals-Spielplan
            smallSemiFinalsSchedule = []; // NEU: Reset kleines Halbfinals-Spielplan
            seventhPlaceMatchSchedule = []; // NEU: Reset Spiel um Platz 7 Spielplan
            fifthPlaceMatchSchedule = []; // NEU: Reset Spiel um Platz 5 Spielplan
            semiFinalsSchedule = []; // Reset Halbfinals-Spielplan
            thirdPlaceMatchSchedule = []; // Reset Spiel um Platz 3 Spielplan
            finalMatchSchedule = []; // Reset Finalspielplan

            // NEU: Reset Endgültige Platzierungen
            for (const key in finalRankings) {
                if (finalRankings.hasOwnProperty(key)) {
                    delete finalRankings[key];
                }
            }

            // Initialisiere teamStats und groupMatchResults neu
            for (const groupKey in groups) {
                groups[groupKey].teams.forEach(team => {
                    teamStats[team] = {
                        spiele: 0,
                        siege: 0,
                        unentschieden: 0,
                        niederlagen: 0,
                        tore: 0,
                        gegentore: 0,
                        tordifferenz: 0,
                        punkte: 0,
                        group: groupKey,
                        lastPlayedTime: null,
                        lastPlayedTable: null
                    };
                });
                groupMatchResults[groupKey] = [];
            }
            groupStageEndTime = null;
            placementRoundStartTime = null;
            quarterFinalsStartTime = null;
            smallSemiFinalsStartTime = null; // NEU
        }

        document.addEventListener('DOMContentLoaded', () => {
            showScreen('start-screen');
        });

        function goToDetailConfiguration() {
            numGroups = parseInt(document.getElementById('numGroups').value);
            teamsPerGroup = parseInt(document.getElementById('teamsPerGroup').value);

            // Angepasste Validierung für 3 Gruppen und 5 Teams
            if (isNaN(numGroups) || numGroups < 1 || numGroups > 3 || isNaN(teamsPerGroup) || teamsPerGroup < 2 || teamsPerGroup > 5) {
                alert("Bitte geben Sie gültige Werte ein: 1-3 Gruppen und 2-5 Teams pro Gruppe.");
                return;
            }
            showScreen('tournament-details-screen');
        }

        function configureTeams() {
            startTime = document.getElementById('startTime').value;
            matchDuration = parseInt(document.getElementById('matchDuration').value);
            breakDuration = parseInt(document.getElementById('breakDuration').value);
            numTables = parseInt(document.getElementById('numTables').value);

            if (isNaN(matchDuration) || matchDuration < 1 || isNaN(breakDuration) || breakDuration < 0 || isNaN(numTables) || numTables < 1) {
                alert("Bitte geben Sie gültige Werte für Spiellänge, Pausenzeiten und Anzahl der Spieltische ein.");
                return;
            }

            const teamNameInputsDiv = document.getElementById('teamNameInputs');
            teamNameInputsDiv.innerHTML = '';
            groups = {};

            const groupLetters = ['A', 'B', 'C']; // Angepasst auf 3 Gruppen

            for (let i = 0; i < numGroups; i++) {
                const groupKey = groupLetters[i];
                groups[groupKey] = { name: `Gruppe ${groupKey}`, teams: [] };

                const groupHeaderDiv = document.createElement('div');
                groupHeaderDiv.className = 'form-group';
                groupHeaderDiv.innerHTML = `
                    <label for="groupName-${groupKey}">Name für Gruppe ${groupKey}:</label>
                    <input type="text" id="groupName-${groupKey}" value="Gruppe ${groupKey}" placeholder="Name für Gruppe ${groupKey}">
                `;
                teamNameInputsDiv.appendChild(groupHeaderDiv);

                for (let j = 0; j < teamsPerGroup; j++) {
                    const teamId = `team-${groupKey}-${j + 1}`;
                    const inputDiv = document.createElement('div');
                    inputDiv.className = 'form-group';
                    inputDiv.innerHTML = `
                        <label for="${teamId}">Team ${j + 1} in ${groups[groupKey].name} Name:</label>
                        <input type="text" id="${teamId}" value="Team ${groupKey}${j + 1}" placeholder="Name für Team ${j + 1}">
                        <div class="logo-upload-group">
                            <label for="logo-${teamId}">Logo:</label>
                            <input type="file" id="logo-${teamId}" accept="image/*" onchange="previewTeamLogo('${teamId}')">
                            <img id="logo-preview-${teamId}" class="team-logo-preview" src="#" alt="Logo Preview">
                        </div>
                    `;
                    teamNameInputsDiv.appendChild(inputDiv);
                }
            }
            showScreen('team-naming-screen');
        }

        function previewTeamLogo(teamId) {
            const fileInput = document.getElementById(`logo-${teamId}`);
            const previewImg = document.getElementById(`logo-preview-${teamId}`);
            const file = fileInput.files[0];

            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    previewImg.src = e.target.result;
                    previewImg.classList.add('active');
                };
                reader.readAsDataURL(file);
            } else {
                previewImg.src = "#";
                previewImg.classList.remove('active');
            }
        }


        async function generateTournament() {
            try {
                const groupLetters = ['A', 'B', 'C']; // Angepasst auf 3 Gruppen

                // Lösche alle vorhandenen Logos vor der Neuerfassung
                for (const key in teamLogos) {
                    if (teamLogos.hasOwnProperty(key)) {
                        delete teamLogos[key];
                    }
                }

                const logoPromises = [];

                for (let i = 0; i < numGroups; i++) {
                    const groupKey = groupLetters[i];
                    const groupNameInput = document.getElementById(`groupName-${groupKey}`);
                    let customGroupName = groupNameInput.value.trim();
                    if (!customGroupName) {
                        customGroupName = `Gruppe ${groupKey}`;
                    }

                    groups[groupKey].name = customGroupName;
                    groups[groupKey].teams = [];

                    for (let j = 0; j < teamsPerGroup; j++) {
                        const teamId = `team-${groupKey}-${j + 1}`;
                        const teamNameInput = document.getElementById(teamId);
                        const logoInput = document.getElementById(`logo-${teamId}`);

                        let teamName = teamNameInput.value.trim();
                        if (!teamName) {
                            teamName = `Team ${groupKey}${j + 1}`;
                        }
                        groups[groupKey].teams.push(teamName);

                        if (logoInput.files.length > 0) {
                            const file = logoInput.files[0];
                            logoPromises.push(new Promise((resolve) => {
                                const reader = new FileReader();
                                reader.onload = (e) => {
                                    teamLogos[teamName] = e.target.result;
                                    resolve();
                                };
                                reader.readAsDataURL(file);
                            }));
                        } else {
                            teamLogos[teamName] = null;
                        }
                    }
                }

                await Promise.all(logoPromises);

                initializeTournamentData();
                generatePreliminaryRoundSchedule(); // NEU: Generiere nur den Vorrunden-Spielplan
                renderPreliminaryRoundSchedule(); // NEU: Render nur den Vorrunden-Spielplan
                renderGroupTables();
                updateAllTables(); // Stellt sicher, dass die Gesamtrangliste initial aktualisiert wird, nachdem die Vorrunde generiert wurde.
                updateTournamentDetailsSummary();

                // Cross-Spiele Sektion ausblenden
                document.getElementById('cross-games-section').style.display = 'none';

                // Finalrunden-Sektion und Platzierungsrunden-Sektion beim Generieren des Turniers ausblenden,
                // werden bei Bedarf angezeigt und befüllt
                document.getElementById('final-round-section').style.display = 'none';
                document.getElementById('quarter-finals-container').innerHTML = ''; // Leere Viertelfinal-Container
                document.getElementById('small-semi-finals-container').innerHTML = ''; // NEU: Leere kleines Halbfinale Container
                document.getElementById('seventh-place-container').innerHTML = ''; // NEU: Leere Spiel um Platz 7 Container
                document.getElementById('fifth-place-container').innerHTML = ''; // NEU: Leere Spiel um Platz 5 Container
                document.getElementById('semi-finals-container').innerHTML = ''; // Leere Halbfinal-Container
                document.getElementById('third-place-container').innerHTML = ''; // Leere Spiel um Platz 3 Container
                document.getElementById('final-container').innerHTML = ''; // Leere Final-Container

                document.getElementById('placement-round-section').style.display = 'none';
                document.getElementById('placement-matches-container').innerHTML = '';

                // NEU: Initialisiere die Gesamtrangliste und Endrundentabelle
                renderOverallStandingsTable();
                renderFinalRankingsTable(); // Initialisiere die neue Endrundentabelle

                showScreen('tournament-screen');
            } catch (error) {
                console.error("Fehler beim Generieren des Turniers:", error);
                alert("Es ist ein unerwarteter Fehler aufgetreten. Bitte überprüfen Sie die Browser-Konsole für Details.");
            }
        }

        function updateTournamentDetailsSummary() {
            const summaryDiv = document.getElementById('tournament-details-summary');
            summaryDiv.innerHTML = `
                <h3>Turnierdetails:</h3>
                <p><strong>Startzeit:</strong> ${startTime}</p>
                <p><strong>Spiellänge:</strong> ${matchDuration} Minuten</p>
                <p><strong>Pausenzeit:</strong> ${breakDuration} Minuten</p>
                <p><strong>Anzahl Spieltische:</strong> ${numTables}</p>
                <p><strong>Gruppen:</strong> ${numGroups}</p>
                <p><strong>Teams pro Gruppe:</strong> ${teamsPerGroup}</p>
            `;
        }

        /**
         * Berechnet den Spielplan für eine Liste von Matches.
         * Berücksichtigt die Spielzeit, Pausen, Anzahl der Tische und Fairness bei der Zuweisung.
         * @param {Array<Object>} matches - Array von Match-Objekten, die geplant werden sollen.
         * @param {number} matchDuration - Dauer eines Matches in Minuten.
         * @param {number} breakDuration - Dauer der Pause zwischen Matches in Minuten.
         * @param {string|Date} currentStartTime - Die Startzeit für die erste Runde als String (HH:MM) oder Date-Objekt.
         * @param {number} numTables - Anzahl der gleichzeitig verfügbaren Spieltische.
         * @param {Array<Object>} prevSchedule - Bereits geplanter Spielplan, um die `lastPlayedTime` und `lastPlayedTable` der Teams zu berücksichtigen.
         * @returns {Array<Object>} Der vollständige, sortierte Spielplan mit Zeiten und Tischen.
         */
        function calculateGameSchedule(matches, matchDuration, breakDuration, currentStartTime, numTables, prevSchedule = []) {
            let startDateTime;
            if (typeof currentStartTime === 'string') {
                startDateTime = new Date(`2000-01-01T${currentStartTime}:00`);
            } else if (currentStartTime instanceof Date) {
                startDateTime = new Date(currentStartTime.getTime()); // Kopie erstellen
            } else {
                console.error("Ungültiger Typ für currentStartTime:", currentStartTime);
                startDateTime = new Date(); // Fallback zu aktueller Zeit
            }

            // Filtere bereits geplante Matches NUR nach ID und Typ,
            // um Duplikate zu vermeiden, aber nicht nach genauen Teams.
            // Dies ist wichtig, da TBA-Matches später mit realen Teams überschrieben werden.
            // Die prevSchedule enthält den gesamten bisherigen Spielplan, um die `lastPlayedTime` und `lastPlayedTable` zu initialisieren.
            let gamesToSchedule = [...matches.filter(m => !prevSchedule.some(sg =>
                sg.match.id === m.id
            ))];
            
            // Initialisiere den Spielplan mit allen bereits geplanten Spielen, die an `prevSchedule` übergeben wurden.
            // Diese werden dann bei der Zeitplanung berücksichtigt, damit `lastPlayedTime`/`lastPlayedTable` korrekt sind.
            const scheduledGames = [...prevSchedule.filter(sg => sg.time && sg.table)]; // Nur wirklich geplante Spiele übernehmen

            let currentRoundStartTime = new Date(startDateTime);
            const slotDuration = matchDuration + breakDuration;

            // Setze lastPlayedTime und lastPlayedTable für alle Teams auf null,
            // um sie basierend auf dem `scheduledGames` Array (aus `prevSchedule`) neu zu initialisieren.
            for (const teamName in teamStats) {
                teamStats[teamName].lastPlayedTime = null;
                teamStats[teamName].lastPlayedTable = null;
            }

            // Aktualisiere lastPlayedTime und lastPlayedTable basierend auf ALLEN bereits geplanten Spielen (aus prevSchedule).
            // Dies ist wichtig, damit die Planung nachfolgender Runden die Gesamt-Historie berücksichtigt.
            // Sortiere `scheduledGames` nach Zeit, um korrekte `lastPlayedTime` zu gewährleisten.
            scheduledGames.sort((a,b) => {
                if (a.time !== b.time) return a.time.localeCompare(b.time);
                return a.table - b.table;
            }).forEach(game => {
                // Nur aktualisieren, wenn das Team in teamStats existiert und es ein echtes Team ist (nicht 'TBA')
                if (teamStats[game.match.team1] && game.match.team1 !== 'TBA') {
                    teamStats[game.match.team1].lastPlayedTime = new Date(`2000-01-01T${game.time}:00`);
                    teamStats[game.match.team1].lastPlayedTable = game.table;
                }
                if (teamStats[game.match.team2] && game.match.team2 !== 'TBA') {
                    teamStats[game.match.team2].lastPlayedTime = new Date(`2000-01-01T${game.time}:00`);
                    teamStats[game.match.team2].lastPlayedTable = game.table;
                }
            });


            const maxSchedulingIterations = gamesToSchedule.length * (numTables + 1) * 2;
            let iterationCount = 0;

            while (gamesToSchedule.length > 0 && iterationCount < maxSchedulingIterations) {
                iterationCount++;
                let gamesInThisRound = [];
                let tablesUsedInThisRound = new Set();
                let teamsPlayingInThisRound = new Set();

                // Sortiere verfügbare Tische nach der Zeit, wann sie zuletzt benutzt wurden (älteste zuerst)
                let currentTablesAvailable = Array.from({ length: numTables }, (_, i) => i + 1).sort((a, b) => {
                    let lastUsageA = 0;
                    Object.values(teamStats).forEach(stat => {
                        if (stat.lastPlayedTable === a) lastUsageA = Math.max(lastUsageA, stat.lastPlayedTime ? stat.lastPlayedTime.getTime() : 0);
                    });
                    let lastUsageB = 0;
                    Object.values(teamStats).forEach(stat => {
                        if (stat.lastPlayedTable === b) lastUsageB = Math.max(lastUsageB, stat.lastPlayedTime ? stat.lastPlayedTime.getTime() : 0);
                    });
                    return lastUsageA - lastUsageB;
                });

                for (let i = 0; i < numTables; i++) {
                    const currentTable = currentTablesAvailable[i];
                    if (!currentTable || tablesUsedInThisRound.has(currentTable)) continue;

                    let bestMatchIndex = -1;
                    let bestMatchScore = -Infinity;

                    // Filtere Spiele, bei denen die Teams nicht bereits in dieser Runde spielen
                    const possibleGamesForThisSlot = gamesToSchedule.filter(match =>
                        !teamsPlayingInThisRound.has(match.team1) && !teamsPlayingInThisRound.has(match.team2)
                    );

                    for (let j = 0; j < possibleGamesForThisSlot.length; j++) {
                        const match = possibleGamesForThisSlot[j];
                        const team1 = match.team1;
                        const team2 = match.team2;

                        // Wenn TBA-Teams beteiligt sind, geben wir ihnen eine geringere Priorität,
                        // aber erlauben die Planung in den letzten Iterationen, um sie anzuzeigen.
                        let score = 0;
                        if (team1 === 'TBA' || team2 === 'TBA') {
                            score -= 10000; // Sehr niedriger Score, damit sie zuletzt geplant werden
                        }

                        const team1Stat = teamStats[team1];
                        const team2Stat = teamStats[team2];

                        // Prüfe auf "lastPlayedTime" für reale Teams
                        if (team1Stat && team2Stat) {
                            const oneSlotAgo = new Date(currentRoundStartTime.getTime() - slotDuration * 60 * 1000);

                            if (team1Stat.lastPlayedTime !== null && team1Stat.lastPlayedTime.getTime() >= oneSlotAgo.getTime()) {
                                score -= 1000; // Hohe Strafe für aufeinanderfolgende Spiele
                            }
                            if (team2Stat.lastPlayedTime !== null && team2Stat.lastPlayedTime.getTime() >= oneSlotAgo.getTime()) {
                                score -= 1000; // Hohe Strafe für aufeinanderfolgende Spiele
                            }

                            if (team1Stat.lastPlayedTable === currentTable) {
                                score -= 100; // Strafe für gleichen Tisch
                            }
                            if (team2Stat.lastPlayedTable === currentTable) {
                                score -= 100; // Strafe für gleichen Tisch
                            }
                        } else if (team1 !== 'TBA' || team2 !== 'TBA') {
                               // Dies sollte nicht passieren, wenn teamStats korrekt initialisiert sind
                               console.warn(`Team stats not found for non-TBA team: ${team1} or ${team2}. This might indicate a data inconsistency.`);
                               score -= 5000; // Strafe, um diese Matches zuletzt zu planen
                        }

                        score += (possibleGamesForThisSlot.length - j); // Bevorzuge frühere Spiele in der Liste

                        if (score > bestMatchScore) {
                            bestMatchScore = score;
                            bestMatchIndex = gamesToSchedule.indexOf(match);
                        }
                    }

                    if (bestMatchIndex !== -1 && (bestMatchScore > -1000 || gamesToSchedule[bestMatchIndex].team1 === 'TBA' || gamesToSchedule[bestMatchIndex].team2 === 'TBA')) {
                        const scheduledMatch = gamesToSchedule.splice(bestMatchIndex, 1)[0];
                        gamesInThisRound.push({
                            match: scheduledMatch,
                            time: `${currentRoundStartTime.getHours().toString().padStart(2, '0')}:${currentRoundStartTime.getMinutes().toString().padStart(2, '0')}`,
                            table: currentTable
                        });
                        teamsPlayingInThisRound.add(scheduledMatch.team1);
                        teamsPlayingInThisRound.add(scheduledMatch.team2);
                        tablesUsedInThisRound.add(currentTable);

                        // Update lastPlayedTime/Table for scheduled non-TBA teams
                        if (teamStats[scheduledMatch.team1] && scheduledMatch.team1 !== 'TBA') {
                            teamStats[scheduledMatch.team1].lastPlayedTime = new Date(currentRoundStartTime);
                            teamStats[scheduledMatch.team1].lastPlayedTable = currentTable;
                        }
                        if (teamStats[scheduledMatch.team2] && scheduledMatch.team2 !== 'TBA') {
                            teamStats[scheduledMatch.team2].lastPlayedTime = new Date(currentRoundStartTime);
                            teamStats[scheduledMatch.team2].lastPlayedTable = currentTable;
                        }
                    }
                }

                if (gamesInThisRound.length > 0) {
                    scheduledGames.push(...gamesInThisRound);
                    currentRoundStartTime.setMinutes(currentRoundStartTime.getMinutes() + slotDuration);
                } else {
                    // Fallback: If no games can be scheduled in this round, advance time.
                    // This happens if all tables are busy or no valid (non-TBA) matches can be assigned.
                    if (gamesToSchedule.length > 0) {
                        currentRoundStartTime.setMinutes(currentRoundStartTime.getMinutes() + slotDuration);
                    } else {
                        break; // All games scheduled or no more possible games
                    }
                }
            }

            // Add any remaining TBA matches that couldn't be scheduled due to lack of teams/results
            // This ensures they are displayed with TBA.
            gamesToSchedule.forEach((match, index) => {
                // Ensure we don't add duplicates if a TBA match was already in prevSchedule
                const isAlreadyInScheduledGames = scheduledGames.some(sg => sg.match.id === match.id);
                if (!isAlreadyInScheduledGames) {
                    scheduledGames.push({
                        match: match,
                        time: `${currentRoundStartTime.getHours().toString().padStart(2, '0')}:${currentRoundStartTime.getMinutes().toString().padStart(2, '0')}`,
                        table: (index % numTables) + 1 // Assign tables cyclically
                    });
                    // Advance time for these "filler" TBA matches as well
                    currentRoundStartTime.setMinutes(currentRoundStartTime.getMinutes() + slotDuration);
                }
            });


            scheduledGames.sort((a, b) => {
                if (a.time !== b.time) {
                    return a.time.localeCompare(b.time);
                }
                return a.table - b.table;
            });

            return scheduledGames;
        }


        // Generiert den Spielplan für die Vorrunde
        function generatePreliminaryRoundSchedule() {
            preliminaryRoundSchedule = [];
            let allGroupMatches = [];
            const groupLetters = ['A', 'B', 'C']; // Angepasst auf 3 Gruppen
            for (let i = 0; i < numGroups; i++) {
                const groupKey = groupLetters[i];
                const groupTeams = groups[groupKey].teams;
                if (groupTeams && Array.isArray(groupTeams)) {
                    for (let j = 0; j < groupTeams.length; j++) {
                        for (let k = j + 1; k < groupTeams.length; k++) {
                            // Feste ID für Vorrundenspiele, um sie eindeutig zu identifizieren
                            const matchId = `PR-${groupKey}-${groupTeams[j].replace(/\s/g, '')}-${groupTeams[k].replace(/\s/g, '')}`;
                            allGroupMatches.push({ groupKey: groupKey, team1: groupTeams[j], team2: groupTeams[k], isPlacementRound: false, isFinalRound: false, isSmallSemiFinal: false, is7thPlace: false, is5thPlace: false, id: matchId });
                        }
                    }
                }
            }

            preliminaryRoundSchedule = calculateGameSchedule(allGroupMatches, matchDuration, breakDuration, startTime, numTables);

            // Determine group stage end time based on the last scheduled preliminary game
            if (preliminaryRoundSchedule.length > 0) {
                const lastScheduledGroupGame = preliminaryRoundSchedule[preliminaryRoundSchedule.length - 1];
                const [hours, minutes] = lastScheduledGroupGame.time.split(':').map(Number);
                let tempEndTime = new Date(`2000-01-01T${hours}:${minutes}:00`);
                tempEndTime.setMinutes(tempEndTime.getMinutes() + matchDuration);
                tempEndTime.setMinutes(tempEndTime.getMinutes() + breakDuration);
                groupStageEndTime = `${tempEndTime.getHours().toString().padStart(2, '0')}:${tempEndTime.getMinutes().toString().padStart(2, '0')}`;
            } else {
                groupStageEndTime = startTime; // If no games, end time is start time
            }
            // Setzt die Startzeit für Platzierungsspiele direkt nach der Gruppenphase
            placementRoundStartTime = groupStageEndTime;
        }

        // Rendert den Spielplan für die Vorrunde
        function renderPreliminaryRoundSchedule() {
            const scheduledMatchesContainer = document.getElementById('scheduled-matches-container');
            scheduledMatchesContainer.innerHTML = '';

            preliminaryRoundSchedule.forEach(scheduleEntry => {
                const team1 = scheduleEntry.match.team1;
                const team2 = scheduleEntry.match.team2;
                const groupKeyForMatch = scheduleEntry.match.groupKey;
                const matchId = scheduleEntry.match.id;

                let existingMatch = groupMatchResults[groupKeyForMatch]?.find(m => m.id === matchId);

                const matchInput = createMatchInput(groupKeyForMatch, team1, team2, false, false, false, false, false, false, existingMatch, scheduleEntry.time, scheduleEntry.table, matchId, 'Preliminary');
                scheduledMatchesContainer.appendChild(matchInput);
            });
        }


        // Erstellt das HTML-Element für ein Spielergebnis-Eingabefeld
        function createMatchInput(groupKey, team1, team2, isCrossGame = false, isFinalRound = false, isPlacementRound = false, isSmallSemiFinal = false, is7thPlace = false, is5thPlace = false, initialScores = null, gameTime = null, tableNumber = null, matchId = null, matchType = null) {
            const div = document.createElement('div');
            div.className = 'match-input';
            if (matchId) div.setAttribute('data-match-id', matchId);
            if (matchType) div.setAttribute('data-match-type', matchType);

            if (is7thPlace || is5thPlace) { // Prioritize specific placement over general final round
                div.classList.add('placement-round-match'); // Reuse styling for placement matches
            } else if (isSmallSemiFinal) {
                div.classList.add('small-semi-final-match');
            } else if (isPlacementRound) {
                div.classList.add('placement-round-match');
            } else if (isFinalRound) {
                div.classList.add('final-round-match');
            }

            const team1LogoSrc = teamLogos[team1] || '';
            const team2LogoSrc = teamLogos[team2] || '';

            const team1LogoHtml = team1LogoSrc ? `<img src="${team1LogoSrc}" alt="${team1} Logo" class="team-logo">` : '';
            const team2LogoHtml = team2LogoSrc ? `<img src="${team2LogoSrc}" alt="${team2} Logo" class="team-logo">` : '';

            const displayGameTime = gameTime && gameTime !== 'NaN:NaN' ? gameTime : 'N/A';
            const timeAndTableDisplay = (displayGameTime !== 'N/A' && tableNumber) ?
                `<span class="match-time-table">${displayGameTime} (Tisch ${tableNumber})</span>` : '';

            const existingScore1 = initialScores ? (initialScores.score1 !== null ? initialScores.score1 : '') : '';
            const existingScore2 = initialScores ? (initialScores.score2 !== null ? initialScores.score2 : '') : '';
            const isRecorded = (initialScores && initialScores.score1 !== null && initialScores.score2 !== null); // Check for null, not just empty string
            
            // Determine initial disabled state based on TBA teams
            const initialDisable = (team1 === 'TBA' || team2 === 'TBA');
            const disabledAttr = initialDisable ? 'disabled' : '';

            const buttonClass = isRecorded ? 'btn recorded' : 'btn';
            const buttonText = isRecorded ? 'Gespeichert!' : 'Ergebnis eintragen';

            div.innerHTML = `
                ${timeAndTableDisplay}
                ${team1LogoHtml}<span class="team-name">${team1}</span> - ${team2LogoHtml}<span class="team-name">${team2}</span>:
                <input type="number" data-team1="${team1}" data-team2="${team2}" class="score-input score1" min="0" value="${existingScore1}" ${disabledAttr}> :
                <input type="number" data-team1="${team1}" data-team2="${team2}" class="score-input score2" min="0" value="${existingScore2}" ${disabledAttr}>
                <button class="${buttonClass}" onclick="recordScore('${groupKey}', '${team1}', '${team2}', this.parentNode, false, ${isFinalRound}, ${isPlacementRound}, ${isSmallSemiFinal}, ${is7thPlace}, ${is5thPlace}, this, '${matchId || ''}', '${matchType || ''}')" ${disabledAttr}>${buttonText}</button>
            `;

            const score1Input = div.querySelector('.score1');
            const score2Input = div.querySelector('.score2');
            const buttonElement = div.querySelector('button');

            // Add event listener for input changes to re-enable button if changed
            const inputs = [score1Input, score2Input];
            inputs.forEach(input => {
                input.addEventListener('input', () => {
                    const currentScore1 = parseInt(score1Input.value);
                    const currentScore2 = parseInt(score2Input.value);
                    const initialVal1 = initialScores ? initialScores.score1 : null;
                    const initialVal2 = initialScores ? initialScores.score2 : null;

                    // Only enable/disable if not already disabled by TBA teams
                    if (!initialDisable) {
                        if (isNaN(currentScore1) || isNaN(currentScore2) || currentScore1 === currentScore2) {
                            buttonElement.textContent = 'Ergebnis eintragen';
                            buttonElement.classList.remove('recorded');
                            buttonElement.classList.add('btn');
                            buttonElement.disabled = true; // Disable if invalid or tie
                        } else if (currentScore1 !== initialVal1 || currentScore2 !== initialVal2) {
                            buttonElement.textContent = 'Ergebnis aktualisieren';
                            buttonElement.classList.remove('recorded');
                            buttonElement.classList.add('btn');
                            buttonElement.disabled = false;
                        } else { // Scores are valid and same as initial, but button was possibly manually re-enabled
                            buttonElement.textContent = 'Gespeichert!';
                            buttonElement.classList.add('recorded');
                            buttonElement.classList.remove('btn');
                            buttonElement.disabled = true;
                        }
                    }
                });
            });


            return div;
        }

        function recordScore(groupKey, team1, team2, parentNode, isCrossGame = false, isFinalRound = false, isPlacementRound = false, isSmallSemiFinal = false, is7thPlace = false, is5thPlace = false, buttonElement, matchId = null, matchType = null) {
            const score1Input = parentNode.querySelector('.score1');
            const score2Input = parentNode.querySelector('.score2');
            const score1 = parseInt(score1Input.value);
            const score2 = parseInt(score2Input.value);

            if (isNaN(score1) || isNaN(score2)) {
                alert("Bitte gültige Ergebnisse (Zahlen) eingeben.");
                return;
            }

            if (score1 === score2) {
                alert("Unentschieden sind in diesem Turnier nicht möglich. Bitte geben Sie ein klares Ergebnis ein.");
                return;
            }

            const matchData = { team1, team2, score1, score2 };
            if (matchId) {
                matchData.id = matchId;
                matchData.type = matchType;
            }
            if (isPlacementRound) {
                matchData.isPlacementRound = true;
            }
            if (isFinalRound) { // Markiere als Finalrunden-Match
                matchData.isFinalRound = true;
            }
            if (isSmallSemiFinal) { // NEU: Markiere als kleines Halbfinal-Match
                matchData.isSmallSemiFinal = true;
            }
            if (is7thPlace) { // NEU: Markiere als Spiel um Platz 7
                matchData.is7thPlace = true;
            }
            if (is5thPlace) { // NEU: Markiere als Spiel um Platz 5
                matchData.is5thPlace = true;
            }


            if (isPlacementRound || isFinalRound || isSmallSemiFinal || is7thPlace || is5thPlace) { // Speichern der Ergebnisse für Platzierungsspiele und Finalrunden
                if (!finalRoundMatchResults['global']) {
                    finalRoundMatchResults['global'] = [];
                }
                let existingMatchIndex = finalRoundMatchResults['global'].findIndex(m =>
                    m.id === matchId
                );
                if (existingMatchIndex !== -1) {
                    finalRoundMatchResults['global'][existingMatchIndex] = matchData;
                } else {
                    finalRoundMatchResults['global'].push(matchData);
                }
                // NEU: Sofortige Aktualisierung der Finalrunden-Platzierungen nach jedem Ergebnis
                updateFinalRoundAdvancements();
                updatePlacementRoundAdvancements(); // Stelle sicher, dass Platzierungsrunden auch aktualisiert werden
                updateSmallSemiFinalsAdvancements(); // NEU: Aktualisiere auch die kleinen Halbfinals
            } else { // Für Gruppenspiele
                if (!groupMatchResults[groupKey]) {
                    groupMatchResults[groupKey] = [];
                }
                let existingMatchIndex = groupMatchResults[groupKey].findIndex(m =>
                    (m.team1 === team1 && m.team2 === team2 && m.id === matchId) || (m.team1 === team2 && m.team2 === team1 && m.id === matchId)
                );
                if (existingMatchIndex !== -1) {
                    groupMatchResults[groupKey][existingMatchIndex] = matchData;
                } else {
                    groupMatchResults[groupKey].push(matchData);
                }
            }


            if (buttonElement) {
                buttonElement.textContent = 'Gespeichert!';
                buttonElement.classList.add('recorded');
                buttonElement.classList.remove('btn');
                buttonElement.disabled = true; // Disable after recording
                parentNode.querySelectorAll('input').forEach(input => input.disabled = true);
            }

            calculateAllStats(); // Berechnet Statistiken basierend auf Vorrunde
            updateAllTables();
            // NEU: Überprüfe, ob die Gesamtrangliste automatisch gestartet werden soll
            checkAndGenerateOverallStandingsAutomatically();
            checkAndStartPlacementRoundAutomatically(); // Prüfe, ob Platzierungsrunde gestartet werden kann
            checkAndStartQuarterFinalsAutomatically(); // Prüfe, ob Viertelfinale gestartet werden kann
        }

        // Funktion, die prüft, ob die Gesamtrangliste automatisch generiert werden kann
        function checkAndGenerateOverallStandingsAutomatically() {
            const allPrelimGamesRecorded = preliminaryRoundSchedule.every(s => {
                const group = s.match.groupKey;
                const matchFound = groupMatchResults[group]?.find(m => m.id === s.match.id);
                return matchFound && matchFound.score1 !== null && matchFound.score2 !== null;
            });

            if (allPrelimGamesRecorded) {
                updateOverallStandings(); // Generiert die Gesamtrangliste
            }
        }

        // Funktion, die prüft, ob die Platzierungsrunde automatisch gestartet werden kann
        function checkAndStartPlacementRoundAutomatically() {
            const allPrelimGamesRecorded = preliminaryRoundSchedule.every(s => {
                const group = s.match.groupKey;
                const matchFound = groupMatchResults[group]?.find(m => m.id === s.match.id);
                return matchFound && matchFound.score1 !== null && matchFound.score2 !== null;
            });

            // Wenn alle Vorrundenspiele erfasst sind und die Platzierungsrunde noch nicht angezeigt wird
            if (allPrelimGamesRecorded && document.getElementById('placement-round-section').style.display === 'none') {
                startPlacementRound();
            }
        }

        // Funktion, die prüft, ob das Viertelfinale automatisch gestartet werden kann
        function checkAndStartQuarterFinalsAutomatically() {
            // Viertelfinale kann gestartet werden, wenn alle VORRUNDEN-Spiele erfasst sind.
            const allPrelimGamesRecorded = preliminaryRoundSchedule.every(s => {
                const group = s.match.groupKey;
                const matchFound = groupMatchResults[group]?.find(m => m.id === s.match.id);
                return matchFound && matchFound.score1 !== null && matchFound.score2 !== null;
            });
            
            if (allPrelimGamesRecorded && document.getElementById('final-round-section').style.display === 'none') {
                // Zeige die Finalrunde an und generiere die Viertelfinalspiele
                document.getElementById('final-round-section').style.display = 'block';
                // WICHTIG: Hier wird das Viertelfinale das erste Mal generiert, sobald die Teams bekannt sind.
                // Danach wird es durch updateFinalRoundAdvancements() aktualisiert.
                generateQuarterFinalMatches(); 
            }
        }

        // Hilfsfunktion zum Aktualisieren der Team-Statistiken für die Vorrunde
        function updateTeamStatsForPreliminaryAndCrossGames(teamStat, ownScore, opponentScore) {
            teamStat.spiele = (teamStat.spiele || 0) + 1; // Sicherstellen, dass spiele eine Zahl ist
            teamStat.tore = (teamStat.tore || 0) + ownScore;
            teamStat.gegentore = (teamStat.gegentore || 0) + opponentScore;
            teamStat.tordifferenz = teamStat.tore - teamStat.gegentore;

            if (ownScore > opponentScore) {
                teamStat.siege = (teamStat.siege || 0) + 1;
                teamStat.punkte = (teamStat.punkte || 0) + 3;
            } else if (ownScore < opponentScore) {
                teamStat.niederlagen = (teamStat.niederlagen || 0) + 1;
            }
        }

        function calculateAllStats() {
            // Speichere den Zustand von lastPlayedTime und lastPlayedTable, da sie für die Zeitplanung benötigt werden
            const tempLastPlayedInfo = {};
            for (const teamName in teamStats) {
                tempLastPlayedInfo[teamName] = {
                    lastPlayedTime: teamStats[teamName].lastPlayedTime,
                    lastPlayedTable: teamStats[teamName].lastPlayedTable
                };
            }

            // Setze alle Statistiken zurück, außer die Gruppeninformation und lastPlayedTime/Table
            for (const teamName in teamStats) {
                const group = teamStats[teamName].group;
                teamStats[teamName] = {
                    spiele: 0,
                    siege: 0,
                    unentschieden: 0,
                    niederlagen: 0,
                    tore: 0,
                    gegentore: 0,
                    tordifferenz: 0,
                    punkte: 0,
                    group: group,
                    // WICHTIG: lastPlayedTime und lastPlayedTable werden NICHT zurückgesetzt,
                    // da sie für die korrekte Zeitplanung über Runden hinweg benötigt werden.
                    lastPlayedTime: tempLastPlayedInfo[teamName].lastPlayedTime,
                    lastPlayedTable: tempLastPlayedInfo[teamName].lastPlayedTable
                };
            }

            // Berechne Statistiken nur für Gruppenphasen-Spiele (Vorrunde)
            for (const groupKey in groupMatchResults) {
                groupMatchResults[groupKey].forEach(match => {
                    if (match.score1 !== null && match.score2 !== null && teamStats[match.team1] && teamStats[match.team2]) {
                        updateTeamStatsForPreliminaryAndCrossGames(teamStats[match.team1], match.score1, match.score2);
                        updateTeamStatsForPreliminaryAndCrossGames(teamStats[match.team2], match.score2, match.score1);
                    }
                });
            }
        }

        function renderGroupTables() {
            const groupTablesContainer = document.getElementById('group-tables-container');
            groupTablesContainer.innerHTML = ''; // Leere den Container hier.

            // The main heading "Tabellen Vorrunde" is now fixed in HTML
            // We just need to add the individual group table cards here.

            const groupLetters = ['A', 'B', 'C']; // Angepasst auf 3 Gruppen
            for (let i = 0; i < numGroups; i++) {
                const groupKey = groupLetters[i];
                if (groups[groupKey]) {
                    const groupTableCard = document.createElement('div');
                    groupTableCard.className = 'group-table-card';
                    groupTableCard.innerHTML = `
                        <h2>Gruppe ${groupKey} (${groups[groupKey].name})</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Team</th>
                                    <th>Spiele</th>
                                    <th>Siege</th>
                                    <th>Niederl.</th>
                                    <th>Tore</th>
                                    <th>Gegentore</th>
                                    <th>Tordiff.</th>
                                    <th>Punkte</th>
                                </tr>
                            </thead>
                            <tbody id="tableBody${groupKey}"></tbody>
                        </table>
                    `;
                    groupTablesContainer.appendChild(groupTableCard);
                }
            }
        }

        function updateTable(groupKey) {
            const tableBody = document.getElementById(`tableBody${groupKey}`);
            if (!tableBody) return;

            let sortedTeams = Object.keys(teamStats)
                .filter(teamName => teamStats[teamName].group === groupKey)
                .map(teamName => ({ name: teamName, ...teamStats[teamName] }));

            sortedTeams.sort((a, b) => {
                if (b.punkte !== a.punkte) {
                    return b.punkte - a.punkte;
                }
                if (b.tordifferenz !== a.tordifferenz) {
                    return b.tordifferenz - a.tordifferenz;
                }
                return b.tore - a.tore;
            });

            tableBody.innerHTML = '';

            sortedTeams.forEach(team => {
                const row = tableBody.insertRow();
                const teamLogoInTable = teamLogos[team.name] ? `<img src="${teamLogos[team.name]}" alt="${team.name} Logo" class="team-logo">` : '';
                row.innerHTML = `
                    <td>${teamLogoInTable} ${team.name}</td>
                    <td>${team.spiele}</td>
                    <td>${team.siege}</td>
                    <td>${team.niederlagen}</td>
                    <td>${team.tore}</td>
                    <td>${team.gegentore}</td>
                    <td>${team.tordifferenz}</td>
                    <td>${team.punkte}</td>
                `;
            });
        }

        function updateAllTables() {
            calculateAllStats();
            const groupLetters = ['A', 'B', 'C']; // Angepasst auf 3 Gruppen
            for (let i = 0; i < numGroups; i++) {
                const groupKey = groupLetters[i];
                if (groups[groupKey]) {
                    updateTable(groupKey);
                }
            }
            updateOverallStandings(); // Update the overall standings table
        }

        // --- Platzierungsrunden-Logik ---

        function startPlacementRound() {
            document.getElementById('placement-round-section').style.display = 'block';
            generatePlacementMatches();
        }

        function generatePlacementMatches() {
            const placementMatchesContainer = document.getElementById('placement-matches-container');
            
            // Holen der sortierten Gesamt-Tabelle
            const allTeamsSorted = getCombinedRanking();

            // Hole die Endzeit des letzten geplanten Vorrunden-Spiels als Startzeit für die Platzierungsrunde
            let currentPlacementStartTime = groupStageEndTime;

            const newPlacementMatches = [];
            
            // Platz 15 wird direkt in finalRankings gesetzt, wenn genügend Teams vorhanden sind und noch nicht gesetzt
            if (allTeamsSorted.length >= 15 && !finalRankings[15]) {
                finalRankings[15] = allTeamsSorted[14].name; // Index 14 ist Platz 15
                updateFinalRankingsTable(); // Aktualisiere die Endrundentabelle sofort für Platz 15
            }

            // Spiel um Platz 13: Platz 14 gegen Platz 13
            const team14 = allTeamsSorted.length >= 14 ? allTeamsSorted[13].name : 'TBA';
            const team13 = allTeamsSorted.length >= 13 ? allTeamsSorted[12].name : 'TBA';
            if (!placementRoundSchedule.some(m => m.match.id === 'P13')) {
                newPlacementMatches.push({ id: 'P13', team1: team14, team2: team13, isPlacementRound: true, isFinalRound: false, isSmallSemiFinal: false, is7thPlace: false, is5thPlace: false, type: 'P13' });
            } else {
                let existingMatch = placementRoundSchedule.find(m => m.match.id === 'P13').match;
                existingMatch.team1 = team14;
                existingMatch.team2 = team13;
            }


            // Spiel um Platz 11: Platz 12 gegen Platz 11
            const team12 = allTeamsSorted.length >= 12 ? allTeamsSorted[11].name : 'TBA';
            const team11 = allTeamsSorted.length >= 11 ? allTeamsSorted[10].name : 'TBA';
            if (!placementRoundSchedule.some(m => m.match.id === 'P11')) {
                newPlacementMatches.push({ id: 'P11', team1: team12, team2: team11, isPlacementRound: true, isFinalRound: false, isSmallSemiFinal: false, is7thPlace: false, is5thPlace: false, type: 'P11' });
            } else {
                let existingMatch = placementRoundSchedule.find(m => m.match.id === 'P11').match;
                existingMatch.team1 = team12;
                existingMatch.team2 = team11;
            }

            // Spiel um Platz 9: Platz 10 gegen Platz 9
            const team10 = allTeamsSorted.length >= 10 ? allTeamsSorted[9].name : 'TBA';
            const team9 = allTeamsSorted.length >= 9 ? allTeamsSorted[8].name : 'TBA';
            if (!placementRoundSchedule.some(m => m.match.id === 'P9')) {
                newPlacementMatches.push({ id: 'P9', team1: team10, team2: team9, isPlacementRound: true, isFinalRound: false, isSmallSemiFinal: false, is7thPlace: false, is5thPlace: false, type: 'P9' });
            } else {
                let existingMatch = placementRoundSchedule.find(m => m.match.id === 'P9').match;
                existingMatch.team1 = team10;
                existingMatch.team2 = team9;
            }

            // Um die Zeiten fair zu planen, nehmen wir den gesamten bisherigen Spielplan + die neuen Platzierungsspiele als Basis.
            let allScheduledGamesForPlacement = [
                ...preliminaryRoundSchedule, // Alle Vorrundenspiele
                ...placementRoundSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })) // Bereits geplante Platzierungsspiele
            ];

            const combinedScheduledGames = calculateGameSchedule(newPlacementMatches, matchDuration, breakDuration, currentPlacementStartTime, numTables, allScheduledGamesForPlacement);
            
            // Filtere nur die Platzierungsspiele aus dem kombinierten Plan und aktualisiere `placementRoundSchedule`.
            placementRoundSchedule = combinedScheduledGames.filter(s => s.match.isPlacementRound);

            renderPlacementRoundSchedule();
            updatePlacementRoundMatchButtonStates();
        }

        // Rendert den Spielplan für die Platzierungsrunde
        function renderPlacementRoundSchedule() {
            const placementMatchesContainer = document.getElementById('placement-matches-container');
            placementMatchesContainer.innerHTML = ''; // Leere den Container komplett

            const orderedPlacementMatches = [];
            const matchOrder = ['P13', 'P11', 'P9'];

            // Sortiere die Platzierungsspiele, um die gewünschte Reihenfolge zu gewährleisten
            matchOrder.forEach(type => {
                const matchesOfType = placementRoundSchedule.filter(entry => entry.match.type === type);
                matchesOfType.sort((a, b) => {
                    if (a.time !== b.time) return a.time.localeCompare(b.time);
                    return a.table - b.table;
                });
                orderedPlacementMatches.push(...matchesOfType);
            });

            let currentHeading = ""; // Zur Verfolgung der aktuellen Überschrift

            orderedPlacementMatches.forEach(scheduleEntry => {
                let headingText = "";
                if (scheduleEntry.match.type === 'P13') headingText = "Spiel um Platz 13";
                else if (scheduleEntry.match.type === 'P11') headingText = "Spiel um Platz 11";
                else if (scheduleEntry.match.type === 'P9') headingText = "Spiel um Platz 9";

                // Füge die Überschrift nur hinzu, wenn sie neu ist für die aktuelle Serie von Spielen
                if (headingText && headingText !== currentHeading) {
                    const headingElement = document.createElement('h2');
                    headingElement.textContent = headingText;
                    placementMatchesContainer.appendChild(headingElement);
                    currentHeading = headingText; // Aktualisiere die aktuelle Überschrift
                }

                const matchId = scheduleEntry.match.id;
                const team1 = scheduleEntry.match.team1;
                const team2 = scheduleEntry.match.team2;
                const matchType = scheduleEntry.match.type;

                let existingMatchData = finalRoundMatchResults['global'].find(m => m.id === matchId);

                // Erstelle immer ein neues Element, da der Container am Anfang geleert wird
                const matchInputDiv = createMatchInput('Placement', team1, team2, false, false, true, false, false, false, existingMatchData, scheduleEntry.time, scheduleEntry.table, matchId, matchType);
                placementMatchesContainer.appendChild(matchInputDiv);
            });
            updatePlacementRoundMatchButtonStates();
        }

        // Update the state of input fields and buttons for placement round matches
        function updatePlacementRoundMatchButtonStates() {
            const placementContainers = document.getElementById('placement-matches-container').children;

            for (let i = 0; i < placementContainers.length; i++) {
                const matchDiv = placementContainers[i];
                if (matchDiv.tagName === 'H2') continue; // Skip headings

                const button = matchDiv.querySelector('button');
                const inputs = matchDiv.querySelectorAll('input');
                const team1 = matchDiv.querySelector('.team-name:first-of-type')?.textContent;
                const team2 = matchDiv.querySelector('.team-name:last-of-type')?.textContent;
                const matchId = matchDiv.getAttribute('data-match-id');

                const disableDueToTBA = (team1 === 'TBA' || team2 === 'TBA');
                
                const existingMatch = finalRoundMatchResults['global'].find(m => m.id === matchId);
                const isRecorded = (existingMatch && existingMatch.score1 !== null && existingMatch.score2 !== null);

                // Update input values to reflect latest state from existingMatch (if any)
                if (existingMatch) {
                    inputs[0].value = existingMatch.score1 !== null ? existingMatch.score1 : '';
                    inputs[1].value = existingMatch.score2 !== null ? existingMatch.score2 : '';
                }


                if (isRecorded) {
                    button.textContent = 'Gespeichert!';
                    button.classList.add('recorded');
                    button.classList.remove('btn');
                    button.disabled = true; // Disable if already recorded
                    inputs.forEach(input => input.disabled = true);
                } else {
                    button.textContent = 'Ergebnis eintragen';
                    button.classList.remove('recorded');
                    button.classList.add('btn');
                    button.disabled = disableDueToTBA;
                    inputs.forEach(input => input.disabled = disableDueToTBA);
                }
            }
        }

        // Aktualisiert den Fortschritt der Platzierungsrunde und die Endrundentabelle
        function updatePlacementRoundAdvancements() {
            const p13Result = finalRoundMatchResults['global'].find(m => m.id === 'P13');
            if (p13Result && p13Result.score1 !== null && p13Result.score2 !== null) {
                finalRankings[13] = p13Result.score1 > p13Result.score2 ? p13Result.team1 : p13Result.team2;
                finalRankings[14] = p13Result.score1 < p13Result.score2 ? p13Result.team1 : p13Result.team2;
            }

            const p11Result = finalRoundMatchResults['global'].find(m => m.id === 'P11');
            if (p11Result && p11Result.score1 !== null && p11Result.score2 !== null) {
                finalRankings[11] = p11Result.score1 > p11Result.score2 ? p11Result.team1 : p11Result.team2;
                finalRankings[12] = p11Result.score1 < p11Result.score2 ? p11Result.team1 : p11Result.team2;
            }

            const p9Result = finalRoundMatchResults['global'].find(m => m.id === 'P9');
            if (p9Result && p9Result.score1 !== null && p9Result.score2 !== null) {
                finalRankings[9] = p9Result.score1 > p9Result.score2 ? p9Result.team1 : p9Result.team2;
                finalRankings[10] = p9Result.score1 < p9Result.score2 ? p9Result.team1 : p9Result.team2;
            }
            updateFinalRankingsTable(); // Update the final rankings table
            renderPlacementRoundSchedule(); // Re-render to update any TBA teams that are now known
        }

        // Funktion zum Generieren der Viertelfinalspiele
        function generateQuarterFinalMatches() {
            const quarterFinalsContainer = document.getElementById('quarter-finals-container');
            
            // Die Startzeit für die Viertelfinals basiert auf dem letzten Spiel der Platzierungsrunde
            let currentQuarterFinalsStartTime;
            if (placementRoundSchedule.length > 0) {
                const lastPlacementGame = placementRoundSchedule.slice(-1)[0]; // Letztes Element
                currentQuarterFinalsStartTime = getNextAvailableTime(lastPlacementGame.time);
            } else if (preliminaryRoundSchedule.length > 0) {
                const lastPreliminaryGame = preliminaryRoundSchedule.slice(-1)[0];
                currentQuarterFinalsStartTime = getNextAvailableTime(lastPreliminaryGame.time);
            } else {
                currentQuarterFinalsStartTime = startTime;
            }
            
            quarterFinalsStartTime = currentQuarterFinalsStartTime; // Globale Variable aktualisieren

            const allTeamsSorted = getCombinedRanking();
            const top8Teams = allTeamsSorted.length >= 8 ? allTeamsSorted.slice(0, 8).map(team => team.name) : Array(8).fill('TBA');

            const newQuarterFinalMatches = [];

            // Viertelfinal-Paarungen: 1. vs 8., 2. vs 7., 3. vs 6., 4. vs 5.
            const vfMatches = [
                { id: 'VF1', team1: top8Teams[0], team2: top8Teams[7], isFinalRound: true, isSmallSemiFinal: false, is7thPlace: false, is5thPlace: false, type: 'VF1' },
                { id: 'VF2', team1: top8Teams[1], team2: top8Teams[6], isFinalRound: true, isSmallSemiFinal: false, is7thPlace: false, is5thPlace: false, type: 'VF2' },
                { id: 'VF3', team1: top8Teams[2], team2: top8Teams[5], isFinalRound: true, isSmallSemiFinal: false, is7thPlace: false, is5thPlace: false, type: 'VF3' },
                { id: 'VF4', team1: top8Teams[3], team2: top8Teams[4], isFinalRound: true, isSmallSemiFinal: false, is7thPlace: false, is5thPlace: false, type: 'VF4' }
            ];

            // Füge neue Viertelfinal-Matches hinzu oder aktualisiere bestehende
            vfMatches.forEach(match => {
                let existingScheduleEntry = quarterFinalsSchedule.find(s => s.match.id === match.id);
                if (existingScheduleEntry) {
                    existingScheduleEntry.match.team1 = match.team1;
                    existingScheduleEntry.match.team2 = match.team2;
                } else {
                    newQuarterFinalMatches.push(match);
                }
            });

            // Um die Zeiten fair zu planen, nehmen wir den gesamten bisherigen Spielplan + die neuen Viertelfinalspiele als Basis.
            let allScheduledGamesForVF = [
                ...preliminaryRoundSchedule,
                ...placementRoundSchedule,
                ...quarterFinalsSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })) // Bereits geplante VF-Spiele
            ];

            const combinedScheduledGames = calculateGameSchedule(newQuarterFinalMatches, matchDuration, breakDuration, quarterFinalsStartTime, numTables, allScheduledGamesForVF);
            
            // Filtere nur die Viertelfinalspiele aus dem kombinierten Plan und aktualisiere `quarterFinalsSchedule`.
            quarterFinalsSchedule = combinedScheduledGames.filter(s => s.match.isFinalRound && s.match.type.startsWith('VF'));

            // Setze Startzeit für die kleinen Halbfinals
            smallSemiFinalsStartTime = quarterFinalsSchedule.length > 0 ? getNextAvailableTime(quarterFinalsSchedule.slice(-1)[0].time) : quarterFinalsStartTime;

            renderQuarterFinalsSchedule();
            updateFinalRoundMatchButtonStates();
        }

        // Rendert den Spielplan für die Viertelfinalspiele
        function renderQuarterFinalsSchedule() {
            const quarterFinalsContainer = document.getElementById('quarter-finals-container');
            quarterFinalsContainer.innerHTML = ''; // Leere den Container komplett

            quarterFinalsSchedule.sort((a,b) => { // Sicherstellen, dass sie sortiert sind
                if (a.time !== b.time) return a.time.localeCompare(b.time);
                return a.table - b.table;
            });

            quarterFinalsSchedule.forEach(scheduleEntry => {
                const matchId = scheduleEntry.match.id;
                const team1 = scheduleEntry.match.team1;
                const team2 = scheduleEntry.match.team2;
                const matchType = scheduleEntry.match.type;

                let existingMatchData = finalRoundMatchResults['global'].find(m => m.id === matchId);

                const matchInputDiv = createMatchInput('FinalRound', team1, team2, false, true, false, false, false, false, existingMatchData, scheduleEntry.time, scheduleEntry.table, matchId, matchType);
                quarterFinalsContainer.appendChild(matchInputDiv);
            });
            updateFinalRoundMatchButtonStates();
        }

        // NEU: Funktion zum Generieren der kleinen Halbfinalspiele
        function generateSmallSemiFinalMatches() {
            const smallSemiFinalsContainer = document.getElementById('small-semi-finals-container');

            let loserVF1 = 'TBA', loserVF2 = 'TBA', loserVF3 = 'TBA', loserVF4 = 'TBA';

            const vf1Result = finalRoundMatchResults['global'].find(m => m.id === 'VF1');
            const vf2Result = finalRoundMatchResults['global'].find(m => m.id === 'VF2');
            const vf3Result = finalRoundMatchResults['global'].find(m => m.id === 'VF3');
            const vf4Result = finalRoundMatchResults['global'].find(m => m.id === 'VF4');

            if (vf1Result && vf1Result.score1 !== null && vf1Result.score2 !== null) {
                loserVF1 = vf1Result.score1 < vf1Result.score2 ? vf1Result.team1 : vf1Result.team2;
            }
            if (vf2Result && vf2Result.score1 !== null && vf2Result.score2 !== null) {
                loserVF2 = vf2Result.score1 < vf2Result.score2 ? vf2Result.team1 : vf2Result.team2;
            }
            if (vf3Result && vf3Result.score1 !== null && vf3Result.score2 !== null) {
                loserVF3 = vf3Result.score1 < vf3Result.score2 ? vf3Result.team1 : vf3Result.team2;
            }
            if (vf4Result && vf4Result.score1 !== null && vf4Result.score2 !== null) {
                loserVF4 = vf4Result.score1 < vf4Result.score2 ? vf4Result.team1 : vf4Result.team2;
            }

            const newSmallSemiFinalMatches = [];
            const ssfMatches = [
                { id: 'KHF1', team1: loserVF1, team2: loserVF4, isFinalRound: true, isSmallSemiFinal: true, is7thPlace: false, is5thPlace: false, type: 'KHF1' },
                { id: 'KHF2', team1: loserVF2, team2: loserVF3, isFinalRound: true, isSmallSemiFinal: true, is7thPlace: false, is5thPlace: false, type: 'KHF2' }
            ];

            ssfMatches.forEach(match => {
                let existingScheduleEntry = smallSemiFinalsSchedule.find(s => s.match.id === match.id);
                if (existingScheduleEntry) {
                    existingScheduleEntry.match.team1 = match.team1;
                    existingScheduleEntry.match.team2 = match.team2;
                } else {
                    newSmallSemiFinalMatches.push(match);
                }
            });

            // Um die Zeiten fair zu planen, nehmen wir den gesamten bisherigen Spielplan + die neuen kleinen Halbfinalspiele als Basis.
            let allScheduledGamesForSSF = [
                ...preliminaryRoundSchedule,
                ...placementRoundSchedule,
                ...quarterFinalsSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })),
                ...smallSemiFinalsSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })) // Bereits geplante KHF-Spiele
            ];

            const combinedScheduledGames = calculateGameSchedule(newSmallSemiFinalMatches, matchDuration, breakDuration, smallSemiFinalsStartTime, numTables, allScheduledGamesForSSF);

            // Filtere nur die kleinen Halbfinalspiele aus dem kombinierten Plan und aktualisiere `smallSemiFinalsSchedule`.
            smallSemiFinalsSchedule = combinedScheduledGames.filter(s => s.match.isSmallSemiFinal);

            renderSmallSemiFinalsSchedule();
            updateFinalRoundMatchButtonStates();
        }

        // NEU: Rendert den Spielplan für die kleinen Halbfinalspiele
        function renderSmallSemiFinalsSchedule() {
            const smallSemiFinalsContainer = document.getElementById('small-semi-finals-container');
            smallSemiFinalsContainer.innerHTML = ''; // Leere den Container komplett

            smallSemiFinalsSchedule.sort((a,b) => {
                if (a.time !== b.time) return a.time.localeCompare(b.time);
                return a.table - b.table;
            });

            smallSemiFinalsSchedule.forEach(scheduleEntry => {
                const matchId = scheduleEntry.match.id;
                const team1 = scheduleEntry.match.team1;
                const team2 = scheduleEntry.match.team2;
                const matchType = scheduleEntry.match.type;

                let existingMatchData = finalRoundMatchResults['global'].find(m => m.id === matchId);
                
                const matchInputDiv = createMatchInput('FinalRound', team1, team2, false, true, false, true, false, false, existingMatchData, scheduleEntry.time, scheduleEntry.table, matchId, matchType);
                smallSemiFinalsContainer.appendChild(matchInputDiv);
            });
            updateFinalRoundMatchButtonStates();
        }

        // NEU: Logik für die Spiele um Platz 7 und 5
        function generateSeventhAndFifthPlaceMatches() {
            let loserKHF1 = 'TBA', loserKHF2 = 'TBA';
            let winnerKHF1 = 'TBA', winnerKHF2 = 'TBA';

            const khf1Result = finalRoundMatchResults['global'].find(m => m.id === 'KHF1');
            const khf2Result = finalRoundMatchResults['global'].find(m => m.id === 'KHF2');

            if (khf1Result && khf1Result.score1 !== null && khf1Result.score2 !== null) {
                loserKHF1 = khf1Result.score1 < khf1Result.score2 ? khf1Result.team1 : khf1Result.team2;
                winnerKHF1 = khf1Result.score1 > khf1Result.score2 ? khf1Result.team1 : khf1Result.team2;
            }
            if (khf2Result && khf2Result.score1 !== null && khf2Result.score2 !== null) {
                loserKHF2 = khf2Result.score1 < khf2Result.score2 ? khf2Result.team1 : khf2Result.team2;
                winnerKHF2 = khf2Result.score1 > khf2Result.score2 ? khf2Result.team1 : khf2Result.team2;
            }

            const newMatchesToSchedule = [];
            const p7Match = { id: 'P7', team1: loserKHF1, team2: loserKHF2, isFinalRound: true, isSmallSemiFinal: false, is7thPlace: true, is5thPlace: false, type: 'P7' };
            const p5Match = { id: 'P5', team1: winnerKHF1, team2: winnerKHF2, isFinalRound: true, isSmallSemiFinal: false, is7thPlace: false, is5thPlace: true, type: 'P5' };

            let existingP7Schedule = seventhPlaceMatchSchedule.find(s => s.match.id === 'P7');
            if (existingP7Schedule) {
                existingP7Schedule.match.team1 = p7Match.team1;
                existingP7Schedule.match.team2 = p7Match.team2;
            } else {
                newMatchesToSchedule.push(p7Match);
            }

            let existingP5Schedule = fifthPlaceMatchSchedule.find(s => s.match.id === 'P5');
            if (existingP5Schedule) {
                existingP5Schedule.match.team1 = p5Match.team1;
                existingP5Schedule.match.team2 = p5Match.team2;
            } else {
                newMatchesToSchedule.push(p5Match);
            }

            // Die Startzeit für diese Spiele basiert auf dem letzten Spiel des kleinen Halbfinals
            let currentPlacementStartTime;
            if (smallSemiFinalsSchedule.length > 0) {
                const lastSmallSemiFinalGame = smallSemiFinalsSchedule.slice(-1)[0];
                currentPlacementStartTime = getNextAvailableTime(lastSmallSemiFinalGame.time);
            } else if (quarterFinalsSchedule.length > 0) { // Fallback, sollte nicht passieren, wenn KHF schon existiert
                const lastQuarterFinalGame = quarterFinalsSchedule.slice(-1)[0];
                currentPlacementStartTime = getNextAvailableTime(lastQuarterFinalGame.time);
            } else {
                currentPlacementStartTime = quarterFinalsStartTime; // Letzter bekannter Startzeitpunkt
            }
            
            let allScheduledGamesForP7P5 = [
                ...preliminaryRoundSchedule,
                ...placementRoundSchedule,
                ...quarterFinalsSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })),
                ...smallSemiFinalsSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })),
                ...seventhPlaceMatchSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })),
                ...fifthPlaceMatchSchedule.map(s => ({ match: s.match, time: s.time, table: s.table }))
            ];

            const combinedScheduledGames = calculateGameSchedule(newMatchesToSchedule, matchDuration, breakDuration, currentPlacementStartTime, numTables, allScheduledGamesForP7P5);

            seventhPlaceMatchSchedule = combinedScheduledGames.filter(s => s.match.type === 'P7');
            fifthPlaceMatchSchedule = combinedScheduledGames.filter(s => s.match.type === 'P5');

            renderSeventhAndFifthPlaceMatches();
        }

        // NEU: Rendert die Spiele um Platz 7 und 5
        function renderSeventhAndFifthPlaceMatches() {
            const seventhPlaceContainer = document.getElementById('seventh-place-container');
            const fifthPlaceContainer = document.getElementById('fifth-place-container');

            seventhPlaceContainer.innerHTML = ''; // Leere den Container komplett
            seventhPlaceMatchSchedule.sort((a,b) => {if (a.time !== b.time) return a.time.localeCompare(b.time); return a.table - b.table;});
            seventhPlaceMatchSchedule.forEach(scheduleEntry => {
                const matchId = scheduleEntry.match.id;
                const team1 = scheduleEntry.match.team1;
                const team2 = scheduleEntry.match.team2;
                const matchType = scheduleEntry.match.type;

                let existingMatchData = finalRoundMatchResults['global'].find(m => m.id === matchId);
                const matchInputDiv = createMatchInput('FinalRound', team1, team2, false, true, false, false, true, false, existingMatchData, scheduleEntry.time, scheduleEntry.table, matchId, matchType);
                seventhPlaceContainer.appendChild(matchInputDiv);
            });

            fifthPlaceContainer.innerHTML = ''; // Leere den Container komplett
            fifthPlaceMatchSchedule.sort((a,b) => {if (a.time !== b.time) return a.time.localeCompare(b.time); return a.table - b.table;});
            fifthPlaceMatchSchedule.forEach(scheduleEntry => {
                const matchId = scheduleEntry.match.id;
                const team1 = scheduleEntry.match.team1;
                const team2 = scheduleEntry.match.team2;
                const matchType = scheduleEntry.match.type;

                let existingMatchData = finalRoundMatchResults['global'].find(m => m.id === matchId);
                const matchInputDiv = createMatchInput('FinalRound', team1, team2, false, true, false, false, false, true, existingMatchData, scheduleEntry.time, scheduleEntry.table, matchId, matchType);
                fifthPlaceContainer.appendChild(matchInputDiv);
            });
            updateFinalRoundMatchButtonStates();
        }


        // Aktualisiert den Fortschritt der Finalrunde (Viertelfinale, Halbfinale, etc.)
        function updateFinalRoundAdvancements() {
            // Die Reihenfolge der Aufrufe ist hier entscheidend für die Zeitplanung und Team-Zuweisung.

            // 1. Viertelfinalspiele aktualisieren/generieren
            generateQuarterFinalMatches(); 
            renderQuarterFinalsSchedule(); 

            // Bedingung für das Starten der nächsten Runden: Alle Viertelfinalspiele müssen erfasst sein.
            const allQuarterFinalsRecorded = quarterFinalsSchedule.every(s => finalRoundMatchResults['global'].some(m => m.id === s.match.id && m.score1 !== null && m.score2 !== null));

            // 2. Kleine Halbfinals generieren, wenn Viertelfinale abgeschlossen sind
            if (allQuarterFinalsRecorded) {
                generateSmallSemiFinalMatches();
            } else {
                // Wenn Viertelfinale nicht abgeschlossen, kleines Halbfinale als TBA anzeigen
                const smallSemiFinalsContainer = document.getElementById('small-semi-finals-container');
                smallSemiFinalsContainer.innerHTML = '';
                let existingKHF1Match = finalRoundMatchResults['global'].find(m => m.id === 'KHF1');
                let existingKHF2Match = finalRoundMatchResults['global'].find(m => m.id === 'KHF2');
                let currentSmallSemiFinalStartTime = quarterFinalsSchedule.length > 0 ? getNextAvailableTime(quarterFinalsSchedule.slice(-1)[0].time) : quarterFinalsStartTime;

                smallSemiFinalsContainer.appendChild(createMatchInput('FinalRound', 'TBA', 'TBA', false, true, false, true, false, false, existingKHF1Match, currentSmallSemiFinalStartTime, 1, 'KHF1', 'KHF1'));
                smallSemiFinalsContainer.appendChild(createMatchInput('FinalRound', 'TBA', 'TBA', false, true, false, true, false, false, existingKHF2Match, getNextAvailableTime(currentSmallSemiFinalStartTime), 2, 'KHF2', 'KHF2'));
            }
            renderSmallSemiFinalsSchedule();

            // NEU: Halbfinale generieren, wenn Viertelfinale abgeschlossen sind (jetzt hier platziert)
            if (allQuarterFinalsRecorded) {
                generateSemiFinalMatches();
            } else {
                const semiFinalsContainer = document.getElementById('semi-finals-container');
                semiFinalsContainer.innerHTML = '';
                let existingHF1Match = finalRoundMatchResults['global'].find(m => m.id === 'HF1');
                let existingHF2Match = finalRoundMatchResults['global'].find(m => m.id === 'HF2');

                // Die Startzeit für das Halbfinale sollte nach den Viertelfinals sein
                let currentSemiFinalStartTime = quarterFinalsSchedule.length > 0 ? getNextAvailableTime(quarterFinalsSchedule.slice(-1)[0].time) : quarterFinalsStartTime;

                semiFinalsContainer.appendChild(createMatchInput('FinalRound', 'TBA', 'TBA', false, true, false, false, false, false, existingHF1Match, currentSemiFinalStartTime, 1, 'HF1', 'HF1'));
                semiFinalsContainer.appendChild(createMatchInput('FinalRound', 'TBA', 'TBA', false, true, false, false, false, false, existingHF2Match, getNextAvailableTime(currentSemiFinalStartTime), 2, 'HF2', 'HF2'));
            }
            renderSemiFinalsSchedule();


            // 3. Spiele um Platz 7 und 5 generieren, wenn kleine Halbfinals abgeschlossen sind
            const allSmallSemiFinalsRecorded = smallSemiFinalsSchedule.every(s => finalRoundMatchResults['global'].some(m => m.id === s.match.id && m.score1 !== null && m.score2 !== null));
            if (allSmallSemiFinalsRecorded) {
                generateSeventhAndFifthPlaceMatches();
            } else {
                const seventhPlaceContainer = document.getElementById('seventh-place-container');
                const fifthPlaceContainer = document.getElementById('fifth-place-container');
                seventhPlaceContainer.innerHTML = '';
                fifthPlaceContainer.innerHTML = '';
                let current7th5thPlaceStartTime = smallSemiFinalsSchedule.length > 0 ? getNextAvailableTime(smallSemiFinalsSchedule.slice(-1)[0].time) : smallSemiFinalsStartTime;

                let existingP7Match = finalRoundMatchResults['global'].find(m => m.id === 'P7');
                let existingP5Match = finalRoundMatchResults['global'].find(m => m.id === 'P5');

                seventhPlaceContainer.appendChild(createMatchInput('FinalRound', 'TBA', 'TBA', false, true, false, false, true, false, existingP7Match, current7th5thPlaceStartTime, 1, 'P7', 'P7'));
                fifthPlaceContainer.appendChild(createMatchInput('FinalRound', 'TBA', 'TBA', false, true, false, false, false, true, existingP5Match, getNextAvailableTime(current7th5thPlaceStartTime), 2, 'P5', 'P5'));
            }
            renderSeventhAndFifthPlaceMatches();

            // 4. Spiel um Platz 3 und Finale generieren, wenn Halbfinale abgeschlossen sind
            const allSemiFinalsRecordedForFinals = semiFinalsSchedule.every(s => finalRoundMatchResults['global'].some(m => m.id === s.match.id && m.score1 !== null && m.score2 !== null));
            if (allSemiFinalsRecordedForFinals) { // Ensure this uses the correct variable
                generateThirdPlaceAndFinalMatches();
            } else {
                const thirdPlaceContainer = document.getElementById('third-place-container');
                const finalContainer = document.getElementById('final-container');
                thirdPlaceContainer.innerHTML = '';
                finalContainer.innerHTML = '';
                let currentFinalStartTime = semiFinalsSchedule.length > 0 ? getNextAvailableTime(semiFinalsSchedule.slice(-1)[0].time) : quarterFinalsStartTime;

                let existingP3Match = finalRoundMatchResults['global'].find(m => m.id === 'P3');
                let existingFMatch = finalRoundMatchResults['global'].find(m => m.id === 'F');

                thirdPlaceContainer.appendChild(createMatchInput('FinalRound', 'TBA', 'TBA', false, true, false, false, false, false, existingP3Match, currentFinalStartTime, 1, 'P3', 'P3'));
                finalContainer.appendChild(createMatchInput('FinalRound', 'TBA', 'TBA', false, true, false, false, false, false, existingFMatch, getNextAvailableTime(currentFinalStartTime), 1, 'F', 'F'));
            }
            renderThirdPlaceAndFinalMatches();


            // Final Rankings aktualisieren
            const p3Result = finalRoundMatchResults['global'].find(m => m.id === 'P3');
            if (p3Result && p3Result.score1 !== null && p3Result.score2 !== null) {
                finalRankings[3] = p3Result.score1 > p3Result.score2 ? p3Result.team1 : p3Result.team2;
                finalRankings[4] = p3Result.score1 < p3Result.score2 ? p3Result.team1 : p3Result.team2;
            }

            const finalResult = finalRoundMatchResults['global'].find(m => m.id === 'F');
            if (finalResult && finalResult.score1 !== null && finalResult.score2 !== null) {
                finalRankings[1] = finalResult.score1 > finalResult.score2 ? finalResult.team1 : finalResult.team2;
                finalRankings[2] = finalResult.score1 < finalResult.score2 ? finalResult.team1 : finalResult.team2;
            }

            // NEU: Platz 5-8 aus den kleinen Halbfinals und Platzierungsspielen
            const p5Result = finalRoundMatchResults['global'].find(m => m.id === 'P5');
            const p7Result = finalRoundMatchResults['global'].find(m => m.id === 'P7');

            if (p5Result && p5Result.score1 !== null && p5Result.score2 !== null) {
                finalRankings[5] = p5Result.score1 > p5Result.score2 ? p5Result.team1 : p5Result.team2;
                finalRankings[6] = p5Result.score1 < p5Result.score2 ? p5Result.team1 : p5Result.team2;
            }
            if (p7Result && p7Result.score1 !== null && p7Result.score2 !== null) {
                finalRankings[7] = p7Result.score1 > p7Result.score2 ? p7Result.team1 : p7Result.team2;
                finalRankings[8] = p7Result.score1 < p7Result.score2 ? p7Result.team1 : p7Result.team2;
            }


            updateFinalRankingsTable();
            updateFinalRoundMatchButtonStates();
        }

        // NEU: Hilfsfunktion zum Aktualisieren der Platzierungen nach den kleinen Halbfinals
        function updateSmallSemiFinalsAdvancements() {
            // Diese Funktion wird nun hauptsächlich dazu dienen, die `generateSeventhAndFifthPlaceMatches()` zu triggern,
            // wenn die kleinen Halbfinals abgeschlossen sind. Die Platzierungen selbst werden in `updateFinalRoundAdvancements`
            // nach den P5- und P7-Spielen aktualisiert.
        }


        function getNextAvailableTime(previousMatchTime) {
            const [hours, minutes] = previousMatchTime.split(':').map(Number);
            let nextTime = new Date(`2000-01-01T${hours}:${minutes}:00`);
            nextTime.setMinutes(nextTime.getMinutes() + matchDuration + breakDuration);
            return `${nextTime.getHours().toString().padStart(2, '0')}:${nextTime.getMinutes().toString().padStart(2, '0')}`;
        }


        function generateSemiFinalMatches() {
            let sf1Team1 = 'TBA', sf1Team2 = 'TBA';
            let sf2Team1 = 'TBA', sf2Team2 = 'TBA';

            // Ermittle Gewinner der Viertelfinals für Halbfinale
            const vf1Result = finalRoundMatchResults['global'].find(m => m.id === 'VF1');
            const vf2Result = finalRoundMatchResults['global'].find(m => m.id === 'VF2');
            const vf3Result = finalRoundMatchResults['global'].find(m => m.id === 'VF3');
            const vf4Result = finalRoundMatchResults['global'].find(m => m.id === 'VF4');

            if (vf1Result && vf1Result.score1 !== null && vf1Result.score2 !== null) {
                sf1Team1 = vf1Result.score1 > vf1Result.score2 ? vf1Result.team1 : vf1Result.team2;
            }
            if (vf4Result && vf4Result.score1 !== null && vf4Result.score2 !== null) {
                sf1Team2 = vf4Result.score1 > vf4Result.score2 ? vf4Result.team1 : vf4Result.team2;
            }
            if (vf2Result && vf2Result.score1 !== null && vf2Result.score2 !== null) {
                sf2Team1 = vf2Result.score1 > vf2Result.score2 ? vf2Result.team1 : vf2Result.team2;
            }
            if (vf3Result && vf3Result.score1 !== null && vf3Result.score2 !== null) {
                sf2Team2 = vf3Result.score1 > vf3Result.score2 ? vf3Result.team1 : vf3Result.team2; // Corrected line
            }

            const newSemiFinalMatches = [];
            const hfMatches = [
                { id: 'HF1', team1: sf1Team1, team2: sf1Team2, isFinalRound: true, isSmallSemiFinal: false, is7thPlace: false, is5thPlace: false, type: 'HF1' },
                { id: 'HF2', team1: sf2Team1, team2: sf2Team2, isFinalRound: true, isSmallSemiFinal: false, is7thPlace: false, is5thPlace: false, type: 'HF2' }
            ];

            hfMatches.forEach(match => {
                let existingScheduleEntry = semiFinalsSchedule.find(s => s.match.id === match.id);
                if (existingScheduleEntry) {
                    existingScheduleEntry.match.team1 = match.team1;
                    existingScheduleEntry.match.team2 = match.team2;
                } else {
                    newSemiFinalMatches.push(match);
                }
            });

            // Die Startzeit für das Halbfinale sollte nach den Viertelfinals sein
            let currentSemiFinalStartTime = quarterFinalsSchedule.length > 0 ? getNextAvailableTime(quarterFinalsSchedule.slice(-1)[0].time) : quarterFinalsStartTime;
            
            let allScheduledGamesForSemi = [
                ...preliminaryRoundSchedule,
                ...placementRoundSchedule,
                ...quarterFinalsSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })),
                // WICHTIG: Die Reihenfolge der bereits geplanten Spiele ist wichtig für calculateGameSchedule
                // Kleinere Halbfinals und Platzierungsspiele können hier übersprungen werden,
                // da sie für die Zeitplanung der HALBFINALS (Hauptbaum) nicht relevant sind,
                // ABER sie müssen im calculateGameSchedule als prevSchedule berücksichtigt werden,
                // um die fairness der Tischbelegung zu gewährleisten.
                // Es ist besser, alle relevanten *bereits geplanten* Spiele hier zu übergeben,
                // um sicherzustellen, dass die lastPlayedTime/Table korrekt ist.
                ...smallSemiFinalsSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })),
                ...seventhPlaceMatchSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })),
                ...fifthPlaceMatchSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })),
                ...semiFinalsSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })) // Already scheduled HF matches
            ];

            const combinedScheduledGames = calculateGameSchedule(newSemiFinalMatches, matchDuration, breakDuration, currentSemiFinalStartTime, numTables, allScheduledGamesForSemi);
            
            semiFinalsSchedule = combinedScheduledGames.filter(s => s.match.isFinalRound && s.match.type.startsWith('HF'));
        }

        function renderSemiFinalsSchedule() {
            const semiFinalsContainer = document.getElementById('semi-finals-container');
            semiFinalsContainer.innerHTML = ''; // Leere den Container komplett

            semiFinalsSchedule.sort((a,b) => {
                if (a.time !== b.time) return a.time.localeCompare(b.time);
                return a.table - b.table;
            });

            semiFinalsSchedule.forEach(scheduleEntry => {
                const matchId = scheduleEntry.match.id;
                const team1 = scheduleEntry.match.team1;
                const team2 = scheduleEntry.match.team2;
                const matchType = scheduleEntry.match.type;

                let existingMatchData = finalRoundMatchResults['global'].find(m => m.id === matchId);
                
                const matchInputDiv = createMatchInput('FinalRound', team1, team2, false, true, false, false, false, false, existingMatchData, scheduleEntry.time, scheduleEntry.table, matchId, matchType);
                semiFinalsContainer.appendChild(matchInputDiv);
            });
            updateFinalRoundMatchButtonStates();
        }

        function generateThirdPlaceAndFinalMatches() {
            const hf1Result = finalRoundMatchResults['global'].find(m => m.id === 'HF1');
            const hf2Result = finalRoundMatchResults['global'].find(m => m.id === 'HF2');

            let loserHF1 = 'TBA', loserHF2 = 'TBA';
            let winnerHF1 = 'TBA', winnerHF2 = 'TBA';

            if (hf1Result && hf1Result.score1 !== null && hf1Result.score2 !== null) {
                loserHF1 = hf1Result.score1 < hf1Result.score2 ? hf1Result.team1 : hf1Result.team2;
                winnerHF1 = hf1Result.score1 > hf1Result.score2 ? hf1Result.team1 : hf1Result.team2;
            }
            if (hf2Result && hf2Result.score1 !== null && hf2Result.score2 !== null) {
                loserHF2 = hf2Result.score1 < hf2Result.score2 ? hf2Result.team1 : hf2Result.team2;
                winnerHF2 = hf2Result.score1 > hf2Result.score2 ? hf2Result.team1 : hf2Result.team2;
            }

            const newMatchesToSchedule = [];
            const p3Match = { id: 'P3', team1: loserHF1, team2: loserHF2, isFinalRound: true, isSmallSemiFinal: false, is7thPlace: false, is5thPlace: false, type: 'P3' };
            const finalMatch = { id: 'F', team1: winnerHF1, team2: winnerHF2, isFinalRound: true, isSmallSemiFinal: false, is7thPlace: false, is5thPlace: false, type: 'F' };

            let existingP3Schedule = thirdPlaceMatchSchedule.find(s => s.match.id === 'P3');
            if (existingP3Schedule) {
                existingP3Schedule.match.team1 = p3Match.team1;
                existingP3Schedule.match.team2 = p3Match.team2;
            } else {
                newMatchesToSchedule.push(p3Match);
            }

            let existingFinalSchedule = finalMatchSchedule.find(s => s.match.id === 'F');
            if (existingFinalSchedule) {
                existingFinalSchedule.match.team1 = finalMatch.team1;
                existingFinalSchedule.match.team2 = finalMatch.team2;
            } else {
                newMatchesToSchedule.push(finalMatch);
            }

            // Startzeitpunkt für das Spiel um Platz 3 und Finale ist nach dem letzten Halbfinalspiel
            let currentFinalStartTime;
            if (semiFinalsSchedule.length > 0) {
                const lastSemiFinalGame = semiFinalsSchedule.slice(-1)[0];
                currentFinalStartTime = getNextAvailableTime(lastSemiFinalGame.time);
            } else {
                // Fallback, sollte nicht passieren, wenn Halbfinale generiert wurde
                currentFinalStartTime = quarterFinalsStartTime; 
            }
            
            let allScheduledGamesForFinals = [
                ...preliminaryRoundSchedule,
                ...placementRoundSchedule,
                ...quarterFinalsSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })),
                ...smallSemiFinalsSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })),
                ...seventhPlaceMatchSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })),
                ...fifthPlaceMatchSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })),
                ...thirdPlaceMatchSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })), // Already scheduled P3 matches
                ...finalMatchSchedule.map(s => ({ match: s.match, time: s.time, table: s.table })) // Already scheduled Final matches
            ];

            const finalMatchesCombinedSchedule = calculateGameSchedule(newMatchesToSchedule, matchDuration, breakDuration, currentFinalStartTime, numTables, allScheduledGamesForFinals);
            
            thirdPlaceMatchSchedule = finalMatchesCombinedSchedule.filter(s => s.match.type === 'P3');
            finalMatchSchedule = finalMatchesCombinedSchedule.filter(s => s.match.type === 'F');
        }

        function renderThirdPlaceAndFinalMatches() {
            const thirdPlaceContainer = document.getElementById('third-place-container');
            const finalContainer = document.getElementById('final-container');

            thirdPlaceContainer.innerHTML = ''; // Leere den Container komplett
            thirdPlaceMatchSchedule.sort((a,b) => {if (a.time !== b.time) return a.time.localeCompare(b.time); return a.table - b.table;});

            thirdPlaceMatchSchedule.forEach(scheduleEntry => {
                const matchId = scheduleEntry.match.id;
                const team1 = scheduleEntry.match.team1;
                const team2 = scheduleEntry.match.team2;
                const matchType = scheduleEntry.match.type;

                let existingMatchData = finalRoundMatchResults['global'].find(m => m.id === matchId);
                const matchInputDiv = createMatchInput('FinalRound', team1, team2, false, true, false, false, false, false, existingMatchData, scheduleEntry.time, scheduleEntry.table, matchId, matchType);
                thirdPlaceContainer.appendChild(matchInputDiv);
            });


            finalContainer.innerHTML = ''; // Leere den Container komplett
            finalMatchSchedule.sort((a,b) => {if (a.time !== b.time) return a.time.localeLocale(b.time); return a.table - b.table;});

            finalMatchSchedule.forEach(scheduleEntry => {
                const matchId = scheduleEntry.match.id;
                const team1 = scheduleEntry.match.team1;
                const team2 = scheduleEntry.match.team2;
                const matchType = scheduleEntry.match.type;

                let existingMatchData = finalRoundMatchResults['global'].find(m => m.id === matchId);
                const matchInputDiv = createMatchInput('FinalRound', team1, team2, false, true, false, false, false, false, existingMatchData, scheduleEntry.time, scheduleEntry.table, matchId, matchType);
                finalContainer.appendChild(matchInputDiv);
            });
            updateFinalRoundMatchButtonStates();
        }


        // Update the state of input fields and buttons for final round matches
        function updateFinalRoundMatchButtonStates() {
            // Updated to iterate over actual elements in the DOM to avoid re-creating everything
            const containers = [
                document.getElementById('quarter-finals-container'),
                document.getElementById('small-semi-finals-container'), // NEU
                document.getElementById('seventh-place-container'), // NEU
                document.getElementById('fifth-place-container'), // NEU
                document.getElementById('semi-finals-container'),
                document.getElementById('third-place-container'),
                document.getElementById('final-container')
            ];

            containers.forEach(container => {
                Array.from(container.children).forEach(matchDiv => {
                    if (matchDiv.tagName === 'H2') return; // Skip headings

                    const button = matchDiv.querySelector('button');
                    const inputs = matchDiv.querySelectorAll('input');
                    const team1 = matchDiv.querySelector('.team-name:first-of-type')?.textContent;
                    const team2 = matchDiv.querySelector('.team-name:last-of-type')?.textContent;
                    const matchId = matchDiv.getAttribute('data-match-id');

                    const disableDueToTBA = (team1 === 'TBA' || team2 === 'TBA');
                    
                    const existingMatch = finalRoundMatchResults['global'].find(m => m.id === matchId);
                    const isRecorded = (existingMatch && existingMatch.score1 !== null && existingMatch.score2 !== null);

                    // Update input values to reflect latest state from existingMatch (if any)
                    if (existingMatch) {
                        inputs[0].value = existingMatch.score1 !== null ? existingMatch.score1 : '';
                        inputs[1].value = existingMatch.score2 !== null ? existingMatch.score2 : '';
                    }


                    if (isRecorded) {
                        button.textContent = 'Gespeichert!';
                        button.classList.add('recorded');
                        button.classList.remove('btn');
                        button.disabled = true;
                        inputs.forEach(input => input.disabled = true);
                    } else {
                        button.textContent = 'Ergebnis eintragen';
                        button.classList.remove('recorded');
                        button.classList.add('btn');
                        button.disabled = disableDueToTBA;
                        inputs.forEach(input => input.disabled = disableDueToTBA);
                    }
                });
            });
        }

        // Funktion zum Abrufen des kombinierten Rankings aller Teams nach der Gruppenphase
        function getCombinedRanking() {
            let allTeams = [];
            for (const teamName in teamStats) {
                allTeams.push({ name: teamName, ...teamStats[teamName] });
            }

            // Sortiere alle Teams nach Punkten, dann Tordifferenz, dann erzielten Toren
            allTeams.sort((a, b) => {
                if (b.punkte !== a.punkte) {
                    return b.punkte - a.punkte;
                }
                if (b.tordifferenz !== a.tordifferenz) {
                    return b.tordifferenz - a.tordifferenz;
                }
                // Handle tie-breaking for teams with same points and goal difference based on 'Tore' (goals scored)
                return b.tore - a.tore;
            });
            return allTeams;
        }

        // Funktion für die Gesamtrangliste (nach Vorrunde)
        function updateOverallStandings() {
            const overallTableBody = document.getElementById('overall-standings-table-body');
            overallTableBody.innerHTML = ''; // Leere die Tabelle vor dem Neubefüllen

            const allTeamsSortedByGroupStats = getCombinedRanking();

            allTeamsSortedByGroupStats.forEach((team, index) => {
                const row = overallTableBody.insertRow();
                const teamLogo = teamLogos[team.name] ? `<img src="${teamLogos[team.name]}" alt="${team.name} Logo" class="team-logo">` : '';
                row.innerHTML = `
                    <td>${index + 1}.</td>
                    <td>${teamLogo} ${team.name}</td>
                    <td>${team.punkte}</td>
                    <td>${team.tordifferenz}</td>
                    <td>${team.tore}</td>
                `;
            });
        }

        function renderOverallStandingsTable() {
            const overallStandingsCard = document.querySelector('.overall-standings-card');
            overallStandingsCard.style.display = 'block'; // Ensure it's visible
            updateOverallStandings();
        }

        // Funktion für die Endrundentabelle
        function updateFinalRankingsTable() {
            const finalRankingsTableBody = document.getElementById('final-rankings-table-body');
            finalRankingsTableBody.innerHTML = ''; // Leere die Tabelle vor dem Neubefüllen

            // Stelle sicher, dass die Endrundentabelle sichtbar ist
            document.querySelector('.final-rankings-card').style.display = 'block';

            // Initialisiere alle Plätze mit TBA, wenn sie noch nicht gefüllt sind
            const totalTeams = numGroups * teamsPerGroup;
            const finalRankingsArray = [];
            for (let i = 1; i <= totalTeams; i++) {
                finalRankingsArray.push({ place: i, teamName: finalRankings[i] || 'TBA' });
            }
            
            // Sortiere nach Platznummer
            finalRankingsArray.sort((a, b) => a.place - b.place);

            finalRankingsArray.forEach(entry => {
                const row = finalRankingsTableBody.insertRow();
                const teamLogo = teamLogos[entry.teamName] && entry.teamName !== 'TBA' ? `<img src="${teamLogos[entry.teamName]}" alt="${entry.teamName} Logo" class="team-logo">` : '';
                row.innerHTML = `<td>${entry.place}.</td><td>${teamLogo} ${entry.teamName}</td>`;
            });
        }

        function renderFinalRankingsTable() {
            // Updated to target the new wrapper for final rankings
            const finalRankingsCard = document.getElementById('final-rankings-wrapper').querySelector('.final-rankings-card');
            if (!finalRankingsCard) { // Create if it doesn't exist (should already be in HTML now)
                const div = document.createElement('div');
                div.className = 'final-rankings-card';
                div.innerHTML = `
                    <h2>Endrundentabelle</h2>
                    <table id="final-rankings-table">
                        <thead>
                            <tr>
                                <th>Platz</th>
                                <th>Team</th>
                            </tr>
                        </thead>
                        <tbody id="final-rankings-table-body">
                        </tbody>
                    </table>
                `;
                document.getElementById('final-rankings-wrapper').appendChild(div);
            }
            updateFinalRankingsTable(); // Initial rendering
        }
    </script>
</body>
</html>